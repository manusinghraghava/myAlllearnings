Spring Security with boot.

Basics.

we use it  to provide application level security.
it is like watchmen of our office which will allow only employee/owners to enter in building and also manage in which area who can go and what can do.

it automatic manage session not need to worry.

can do--->
username/password authentication.
sso/okta/ldap.
App level authorization.
Intra app lik oauth authorization.
microservice security like Jwt.


Spring Security have five level journey.

1.)Authentication  		--- who are you?    need id

2.)Authorization  		--- what you want?   you can access only those area. can user do this operation?yes:no...it happens after authenticate.

3.)Principal      		--- Currently Logged in User.It is attatched with spring Context.

4.)Granted Authority    --- This is how authorization done.

5.)Role                 --- This the group for particular authority.

-------------------------------------------------------------------------------------------------------------------------

AuthenticationManager--->it authenticate user in spring security.It has a method authenticate() which returns authentication object on success or throw Exception.we can get it through authenticationmanagerbuilder and also configure which type of authenticate we want.

how do i get authenticationmanagerbuilder?
create a class which extend websecurityConfigureAdapter and override configure(authenticationmanagerbuilduer auth) method.and provide details here
also put @EnableWebSecurity annotation on class level.

we also have same method which we can overload for paths configure(HttpSecurity http)  and override it.
http.authorizeRequests().antMatchers(//urlpattern).hasRole(//role)  or hasAnyRole().and().formLogin(). //////we can also use any login method.

how spring security works?
by filter--->in non boot project we need to add delegatingfilterproxy manually in xml.....but in boot it automatically configure.

so authentication filter intercepts authentication request...with correct authentication object from its filter chain like (basic authentication).
it creates an authentication object like (Usernamepasswordauthenticationtoken) with credentials and pass it to authentication manager.
authentication manager finds the right authentication provider with the help of supports method.
than authentication manager calls the authenticate() on that provider.
than provider look for the user in the system with the help of userdetailservice by method loadUserByUserName().
userdetailservice than return the userDetails object which provider authenticate and return the authentication object with principal.

if user not get authenticate it will throw an authentication object.if success than attach to its springsecurityContext.

--------------------------------------------------------------------------------------------------------------------------------------------
Core Components-->

SecurityContext
As the name implies, this interface is the corner stone of storing all the security related details for your application. When you enable spring security for your application, a SecurityContext will enable for each application and stores the details of authenticated user, etc. It uses Authentication object for storing the details related to authentications.


SecurityContextHolder
The most fundamental object is SecurityContextHolder. This class is important for accessing any value from the SecurityContext. This is where we store details of the present security context of the application, which includes details of the principal currently using the application. By default the SecurityContextHolder uses a ThreadLocal to store these details, which means that the security context is always available to methods in the same thread of execution, even if the security context is not explicitly passed around as an argument to those methods.
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) {
String username = ((UserDetails)principal).getUsername();
} else {
String username = principal.toString();
}



Authentication
Let’s consider a standard authentication scenario that everyone is familiar with.
A user is prompted to log in with a username and password.
The system verifies that the password is correct for the username.
The context information for that user is obtained their list of roles and so on.
A security context is established for the user
The user proceeds, potentially to perform some operation which is potentially protected by an access control mechanism which checks the required permissions for the operation against the current security context information.
The following are the steps to achieve the authentication:

Authentication is an interface which has several implementations for different authentication models. For a simple user name and password authentication, spring security would use UsernamePasswordAuthenticationToken. When user enters username and password, system creates a new instance of UsernamePasswordAuthenticationToken.

The token is passed to an instance of AuthenticationManager for validation. Internally what AuthenticationManager will do is to iterate the list of configured AuthenticationProvider to validate the request. There should be at least one provider to be configured for the valid authentication.

The AuthenticationManager returns a fully populated Authentication instance on successful authentication.
The final step is to establish a security context by invoking SecurityContextHolder.getContext().setAuthentication(), passing in the returned authentication object.



=======================================================================================================================================
UserDetailsManager--->Allopeartion done on user all crud operations are done by this.

because userdetailservice has only one method to loadUserByUserName.ever provider type has its manager.

---------------------------

Authentication Provider--->it is the main object which tells how to authenticate user...like csrf,usernamepasswordauthenticationtoken etc.

lets create our custom provider--->

public class ReportsAuthenticationProvider implements AuthenticationProvider
{
    private static final Logger logger = LoggerFactory.getLogger(ReportsAuthenticationProvider.class);

    @Inject
    private ProviderDao providerDao;    //our dao to authenticate

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException  //this object before authenticate
    {
        String providerName = (String) authentication.getName();
        String password = (String) authentication.getCredentials();

        Provider provider = providerDao.findByProviderName(providerName);

        if (provider == null)
        {
            logger.error("authenticate() - unknown provider name " + providerName);
            throw new BadCredentialsException("invalid provider");
        }
        else
        {
            if (StringUtils.isEmpty(password))
            {
                logger.error("authenticate() - no password provider for provider " + providerName);
                throw new InsufficientAuthenticationException("No password for user");
            }
            else
            {
                if (password.equals(provider.getPassword()))
                {
				//creating our authentication object.
                    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(providerName, password);
                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);
                    return authenticationToken;
                }
                else
                {
                    logger.error("authenticate() - invalid password for provider " + providerName + " [" + password + "]");
                    throw new BadCredentialsException("invalid credentials");
                }
            }
        }
    }

    @Override
    public boolean supports(Class<?> authentication)
    {
        return UsernamePasswordAuthenticationToken.class.equals(authentication);  //when UsernamePasswordAuthenticationToken comes provider runs.
    }
}

--------------------------------------------------------------------------------------------------------------------------------------
Custom filter-->

1)always create our custom filter by extending onceperrequestfilter.and override its dofilter() method.

2)than we have to create our authentication object.

3)delegate object to authentication manager.

----------------------------------------------------------------------------------------------------------------------------------------
Security context holder holds spring context from where we can fetch authenticated user or object.

====================================================================================================================
remember-me--->

<tr>
                <td>Remember Me:</td>
                <td><input type="checkbox" name="remember-me" /></td>  //should have this name to enable
            </tr>


As you can see, the basic configuration using the rememberMe() method is extremely simple while remaining very flexible through additional options. The key is important here – it is a private value secret for the entire application and it will be used when generating the contents of the token.

Additionally, the time the token is valid can be configured from the default of 2 weeks to – for example – one day using tokenValiditySeconds():

rememberMe().key("uniqueAndSecret").tokenValiditySeconds(86400);

----------------------------------------------------------------------------------------------------------------------------------------
csrf-->by default csrf is enabled in boot.
by csrf token server checks that it is a correct user not a attacker.
so always remember to send csrf in post requests.

in configure(HttpSecurity http)
{
http.csrf(csrf->csrf.ignoringAntMatchers("/g"));   // to remove url from csrf check
}

if we want to use our own csrf token
csrf.csrfTokenRepository(//name of our custom);  class which implements csrfTokenRepository

--------------------------------------------------------------------------------------------------------------------------------------
Filter Ordering
The order that filters are defined in the chain is very important. Irrespective of which filters you are actually using, the order should be as follows:

ChannelProcessingFilter, because it might need to redirect to a different protocol

SecurityContextPersistenceFilter, so a SecurityContext can be set up in the SecurityContextHolder at the beginning of a web request, and any changes to the SecurityContext can be copied to the HttpSession when the web request ends (ready for use with the next web request)

ConcurrentSessionFilter, because it uses the SecurityContextHolder functionality but needs to update the SessionRegistry to reflect ongoing requests from the principal

Authentication processing mechanisms - UsernamePasswordAuthenticationFilter, CasAuthenticationFilter, BasicAuthenticationFilter etc - so that the SecurityContextHolder can be modified to contain a valid Authentication request token

The SecurityContextHolderAwareRequestFilter, if you are using it to install a Spring Security aware HttpServletRequestWrapper into your servlet container

RememberMeAuthenticationFilter, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, and the request presents a cookie that enables remember-me services to take place, a suitable remembered Authentication object will be put there

AnonymousAuthenticationFilter, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, an anonymous Authentication object will be put there

ExceptionTranslationFilter, to catch any Spring Security exceptions so that either an HTTP error response can be returned or an appropriate AuthenticationEntryPoint can be launched

FilterSecurityInterceptor, to protect web URIs and raise exceptions when access is denied

--------------------------------------------------------------------------------------------------------------------------------------
Cross origin resource sharing-->

Lets we want to share our api on different resources(origin).

By default it is disabled in spring security.

so use @CrossOrigin on methods or api which we want to share.
=======================================================================================================================================

=======================================================================================================================================
Oauth --->It is authorization not authentication like JWT. fbk,google all are authorization servers..it is authorization between services.

Consider the use case of Quora. Go to Quora.com.
If you are a new user you need to signup. You can signup using google or facebook account. When doing so you are authorizing Google or Facebook to allow quora to access you profile info with Quora. This authorizing is done using OAuth. Here you have in no way shared your credentials with Quora.

In the above example of Quora, we have 3 actors-
Resource Owner - This is the user who wants to sign up using Quora.
Client Application - This will be Quora
Resource Server - This will be Gmail or Facebook.
Authorization Server - The resource server hosts the protected user accounts, and the authorization server verifies the identity of the user then issues access tokens to the application.


flow-->

In this tutorial we will be implementing our own client application and resource server.
The resource owner will then using OAuth authorize the resource server to share data with the client application.

The client application must first register with the authorization server associated with the resource server. This is usually a one-time task. Once registered, the registration remains valid, unless the client application registration is revoked. At registration the client application is assigned a client ID and a client secret (password) by the authorization server. The client ID and secret is unique to the client application on that authorization server.

a)resource owner comes to quora and try to authenticate via google.
b)then quora go to google say i am quora my clientid is this, a resource owner wants to connect.
c)google ask resource owner to authenticate via username/password.
d)on successful authentication google give a authorization code to quora.
e)now quora gives code/and client secret to google.
f)now google will give a token to quora.
g)now resource server will use this token to share data.


Similar to the above flow we will be developing our own client application and Resource Server. Using OAuth the Resource server will then share the data with the client application. Also we will be assuming that the client is already registered with the Resource Server and has been assigned a unique client id and secret key.
Spring Boot Client Application - We already have a unique client id -'javainuse' and secret key - 'secret'. We need to import data from Resource Server.
Resource Server - Using OAuth we configure authorization server. It already has the unique key configured for recognizing our client application.

In this tutorial we will be implementing the Client Application and the Resource Server. The flow we will be implementing is as follows -
The Resource Owner will ask the Client Application to get some data from the Resource Server.
The Resource Server asks the Resource Owner to authenticate itself and as for authorization to share data.
After successful authentication the Resource Server shares an authorization code with the client application.


so flow--->

a)we will have spring boot client application.
b)client will make a post call to authorize to resource server via client_id.
c)resource owner will authenticate himself via username/password on resource server. and client will get a authorization code.

so first we will create our a get api to fetch employess..//do it yourself

second-->we will enable spring security--->

Finally we will be configuring security. In this configuration we specify which urls are to be intercepted, and are to be accessed by which users and having which roles

 @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().antMatchers("/").permitAll().antMatchers("/user/getEmployeesList")
            .hasAnyRole("ADMIN").anyRequest().authenticated().and().formLogin()
            .permitAll().and().logout().permitAll();

        http.csrf().disable();
    }

    @Override
    public void configure(AuthenticationManagerBuilder authenticationMgr) throws Exception {
        authenticationMgr.inMemoryAuthentication().withUser("admin").password("admin")   // to authenticate on authorization server.
            .authorities("ROLE_ADMIN");
    }


second-->

Next we configure an authorization server using EnableAuthorizationServer annotation.
The server is customized by extending the class AuthorizationServerConfigurerAdapter which provides empty method implementations for the interface AuthorizationServerConfigurer.
The authorization server does not secure the authorization end point i.e. /oauth/authorize. The configure method here injects the Spring Security authentication manager.
Using in memory client service we setup the clients that can access the server.

@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {   //this is authorization server which gives code(resource server)

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory().withClient("javainuse").secret("secret").authorizedGrantTypes("authorization_code")  //creating client
            .scopes("read").authorities("CLIENT").redirectUris(//);
    }
}


Client Application
We will create the client application. This application will ask the resource server we created above for JSON data.
As explained previously we have assumed that this Client Application is already registered to the Resource Server, and has got the client id as 'javainuse' and secret key as 'secret'
According to OAuth spec, it should ask for authorization at the default uri /authorize.
We can change this default uri according to the requirement but we will be using the default one only in this example.
Along with the default uri we should also send the following parameters.
response_type - REQUIRED. Value MUST be set to "code".
client_id - REQUIRED. The client identifier obtained during registration. In our case it is 'javainuse'
redirect_uri - OPTIONAL. After successful authorization, the resource owner should redirect to this uri.
scope - OPTIONAL. The scope of the access request. Can be either Read or Write. We will be using Read value.


In the next tutorial we will do the following flow -
The Client Application using the Authorization code and Secret key ask for the Access Token from the Resource Server.
The Resource Server shares the Access Token with the Client Application.
Using the shared Access Token the Client Application can now get the required JSON data from the Resource Server


As can be seen the authorization code is received as a request parameter. And the resource server is trying to contact the client application using the redirect uri. So we will write a controller to get the Authorization code as a request parameter. Then using this authorization code we get the Access Token.


so we will fetch code from uri-->>

@RequestMapping(value = "/showEmployees", method = RequestMethod.GET)
	public ModelAndView showEmployees(@RequestParam("code") String code) throws JsonProcessingException, IOException { //fetching
		ResponseEntity<String> response = null;
		System.out.println("Authorization Code------" + code);

		RestTemplate restTemplate = new RestTemplate();

		// According OAuth documentation we need to send the client id and secret key in the header for authentication
		String credentials = "javainuse:secret";
		String encodedCredentials = new String(Base64.encodeBase64(credentials.getBytes()));

		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
		headers.add("Authorization", "Basic " + encodedCredentials);  //adding our code

		HttpEntity<String> request = new HttpEntity<String>(headers);

		String access_token_url = "http://localhost:8080/oauth/token";
		access_token_url += "?code=" + code;
		access_token_url += "&grant_type=authorization_code";
		access_token_url += "&redirect_uri=http://localhost:8090/showEmployees";

		response = restTemplate.exchange(access_token_url, HttpMethod.POST, request, String.class);

		System.out.println("Access Token Response ---------" + response.getBody());

		return null;
	}
}



now main we have to make changes for resource server to validate-->


In the Resource Server module we add a configuration class. This class allows any request with valid access token and scope to get the requested resource. We use this to configure the access rules for secure resources
package com.javainuse.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;

@Configuration
@EnableResourceServer   ///////////*************
class ResourceServer extends ResourceServerConfigurerAdapter {
    //Here we specify to allow the request to the url /user/getEmployeesList with valid access token and scope read 
	@Override
	public void configure(HttpSecurity http) throws Exception {
		http.requestMatchers().antMatchers("/user/getEmployeesList/**").and().authorizeRequests().anyRequest()
				.access("#oauth2.hasScope('read')");                     //for read.
	}
}






Spring Security maintains a filter chain internally where each of the filters has a particular responsibility and filters are added or removed from the configuration depending on which services are required. The ordering of the filters is important as there are dependencies between them. If using Spring 1.5 and above there is a ResourceServerProperties issue Next in the properties file add the following property
security.oauth2.resource.filter-order = 3



now some changes in client to use token..

// Get the Access Token From the recieved JSON response
		ObjectMapper mapper = new ObjectMapper();
		JsonNode node = mapper.readTree(response.getBody());
		String token = node.path("access_token").asText();

		String url = "http://localhost:8080/user/getEmployeesList";

		// Use the access token for authentication
		HttpHeaders headers1 = new HttpHeaders();
		headers1.add("Authorization", "Bearer " + token);
		HttpEntity<String> entity = new HttpEntity<>(headers1);

		ResponseEntity<Employee[]> employees = restTemplate.exchange(url, HttpMethod.GET, entity, Employee[].class);
		System.out.println(employees);
		Employee[] employeeArray = employees.getBody();

		ModelAndView model = new ModelAndView("showEmployees");
		model.addObject("employees", Arrays.asList(employeeArray));
		return model;
	}
}

udemy tutorial later.
---------------------------------------------------------------------------------------
in this we mainly use cliet_credentials grant type with refresh token.

Resource Owner(User) - An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user.
Client Application - The machine that needs to be authenticated.
Authorization Server - The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization
Resource Server - The resource server is the OAuth 2.0 term for your API server. The resource server handles authenticated requests after the application has obtained an access token.

resource server and authorization server is always coupled.resource server always check token with authorization server.

isAuthenticated()       Returns true if the user is not anonymous
isFullyAuthenticated()  Returns true if the user is not an anonymous or a remember-me user


Do I Need to Stand Up My Own Authorization Server?
You need to stand up your own authorization server if:

You want to delegate the operations of sign-in, sign-out, and password recovery to a separate service (also called identity federation) that you want to manage yourself and

You want to use the OAuth 2.0 protocol for this separate service to coordinate with other services


If you expose a bean of type AuthorizationServerConfigurer, none of this is done automatically.

So, for example, if you need to configure more than one client, change their allowed grant types, or use something better than the no-op password encoder (highly recommended!), then you want to expose your own AuthorizationServerConfigurer, as the following example shows:

@Configuration
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired DataSource dataSource;

    protected void configure(ClientDetailsServiceConfigurer clients) {
        clients
            .jdbc(this.dataSource)
            .passwordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());
    }
}



Example-->

lets create api which is secure by aouth2.0.

user must authenticated through client_credentials and his username/password.

1)we need  a userModel to fetch data from db.

package com.oauth.config;


import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name="User")
public class User {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String username;
	private String password;
	private boolean active;
	private String roles;
	//getters and setters.
}

2)now we need our user detail object which will get created on this user if user found in database.

public class MyUserDetail implements UserDetails{
	
	private String username;
	private String password;
	private boolean isActive;
	private List<GrantedAuthority> authorities;

	public MyUserDetail(User user) {   //passing our user
		super();
		this.username=user.getUsername();
		this.password=user.getPassword();
		this.isActive = user.isActive();
		this.authorities=Arrays.stream(user.getRoles().split(",")).map(SimpleGrantedAuthority::new).collect(Collectors.toList());
	System.out.println(user.isActive());
	}

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		return this.authorities;
	}

	@Override
	public String getPassword() {
		return this.password;
	}

	@Override
	public String getUsername() {
      return this.username;
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return this.isActive;
	}

}



3)Now we need our user detail service which will return our user detail object if user found in database.


@Service
public class MyUserDetailService implements UserDetailsService{

	@Autowired
	private UserRepository repo;
	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		User user = repo.findByUsername(username).orElse(null);
		
		return new MyUserDetail(user);    // passing our user here.
	}

}

4)now declaring our spring config to protect.

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)//EnableGlobalMethodSecurity provides AOP security on methods. Some of the annotations that it provides are PreAuthorize, PostAuthorize.
public class SpringConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private MyUserDetailService jwtUserDetailsService;
	
	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		// configure AuthenticationManager so that it knows from where to load
		// user for matching credentials
		 auth.userDetailsService(jwtUserDetailsService).passwordEncoder(passwordEncoder());
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
	}

	@Bean
	@Override
	public AuthenticationManager authenticationManagerBean() throws Exception {
		return super.authenticationManagerBean();
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().antMatchers("/hello").authenticated();    //our url which is protected/
	}
}



5)Now creating Authorization server with client to create token....


@Configuration
@EnableAuthorizationServer
public class AuthorizationServer extends AuthorizationServerConfigurerAdapter {
	
	@Autowired
	private AuthenticationManager manager;

	/**
	 * we use it to authenticate user.
	 */
	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		endpoints.authenticationManager(manager);
	}
	/**
	 * this is used for client credentials
	 */
	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		// TODO Auto-generated method stub
		clients.inMemory().withClient("manu").accessTokenValiditySeconds(2000).secret("singh").scopes("read").authorizedGrantTypes("password","refresh_token");
	}
	@Override
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		// TODO Auto-generated method stub
		security.checkTokenAccess("isAuthenticated()");
	}
}


6)Last and main if u r not creating other resource server..please declare your own application as resource server otherwise 403 will throw.

package com.oauth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;

@SpringBootApplication
@EnableResourceServer      // enabling 
public class OauthApplication {

	public static void main(String[] args) {
		SpringApplication.run(OauthApplication.class, args);
	}

}





example curl for postman-->
curl --user client:secret \
  -X POST http://localhost:8080/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=password&username=username&password=password&scope=*" \
  



============================================================================================================================
What's the difference between @Secured and @PreAuthorize in spring security
if you wanted to do something like access the method only if the user has Role1 and Role2 the you would have to use @PreAuthorize @PreAuthorize("hasRole('ROLE_role1') and hasRole('ROLE_role2')") Using @Secured({"role1", "role2"}) is treated as an OR

============================================================================================================================
SSO  ---->

Single sign-on (or SSO) allow users to use a single set of credentials to login into multiple related yet independent web applications. SSO also includes not asking users to login again into application B if they have already logged into application A given that A and B use SSO. 


Benefits of Single sign-on.

Reduced IT support cost: Gartner has reported that 20%-50% of the support tickets are password resets.

Improved User experience: How frustrating it is to keep entering username and password to access different services? Not only this is a bad experience for the user but it also kills their productivity.

Better security: With SSO, you have a single centralised server that manages user identity. It is the responsibility of the SSO users to securely store credentials. Individual services do not need to manage the credentials. Hence, reduce the attack surface area.

flow--->

We have two applications app1.com and app2.com. There is a centralised SSO server login.example.com.

A user goes to the app1.com for the first time. As user is not logged in, a login button is available to the user. User clicks the login button and user is redirected to the SSO server.

User enters credentials on the login page rendered by the SSO server. SSO server validates the credentials and generates a SSO token. SSO server sets the SSO token in the cookie for future login attempts by the user.

SSO server redirects user to the app1.com. In the redirect URL, it also appends SSO token as the query parameter.

app1.com saves the token in its cookie and change view to the logged in user. app1.com can get information about the user either by querying the SSO server or if token is a JWT token then it can get basic user information from the token itself.

Now, the same user tries to access app2.com. As an application can only access cookie for the same origin it has no knowledge that user is logged in to app1.com. So, user will still be shown login button on app2.

User clicks the login button and then user is redirected to the SSO server. SSO server sees that it already has a cookie set so it will immediately redirect the user to app2.com with SSO token appended in the URL as query parameter.

app2.com stores the token in the cookie and change its view to logged in user.
At the end of this process there will be three cookies set in the user browser each for app1.com, app2.com, and login.example.com domains.


1)create sso server first....

create a project with dependency web,cloud-oauth2


Enable authorization server
To make a Spring Boot application act as an authorization server you have to mark it with @EnableAuthorizationServer annotation as shown below.

This is what happens when you add @EnableAuthorizationServer annotation.

This annotation imports two configuration classes — AuthorizationServerEndpointsConfiguration and AuthorizationServerSecurityConfiguration.

The AuthorizationServerEndpointsConfiguration configuration class create beans for three REST controllers — AuthorizationEndpoint, TokenEndpoint, and CheckTokenEndpoint. These three controllers provide implementations for endpoints specified in OAuth2 specification.

The AuthorizationServerSecurityConfiguration configuration class configures Spring Security for OAuth endpoints.




2)Configure Spring Security for login
We will define our own Spring Security configuration class that will use form based login instead of the basic authentication mechanism used with default configuration. To do that, update the SsoServerApplication as shown below.


package com.sso;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;

@EnableAuthorizationServer
@SpringBootApplication
public class Oauth1Application {

	public static void main(String[] args) {
		SpringApplication.run(Oauth1Application.class, args);
	}
	 
	@Configuration
	protected static class LoginConfig extends WebSecurityConfigurerAdapter {
	 
	@Override
	protected void configure(HttpSecurity http) throws Exception {
	http.requestMatchers()
	.antMatchers("/login", "/oauth/authorize")
	.and()                              // and() method which allows us to continue configuring the parent.
	.authorizeRequests()
	.anyRequest().authenticated()      //it means /** request and it should be authenticated first
	.and()
	.formLogin().permitAll();
	}
	 
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth.inMemoryAuthentication()
	.withUser("user")
	.password("password")
	.roles("USER");
	}
	}
}




In the LoginConfig shown above, we are explicitly saying that we want to use this security configuration for only two URLs /login and /oauth.authorize. All other urls will remain unaffected. This is very important to keep in mind.




3)Create OAuth2Config
So far we have not explicitly specified OAuth configuration. Create a new static inner class OAuth2Config to specify OAuth2 configuration as shown below.


@Configuration
@EnableAuthorizationServer
protected static class OAuth2Config extends AuthorizationServerConfigurerAdapter {
@Autowired
private AuthenticationManager authenticationManager;
 
@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
clients.inMemory()
.withClient("foo")
.secret("bar")
.authorizedGrantTypes("authorization_code", "refresh_token", "password")
.scopes("user_info")
.autoApprove(true).redirectUris(//whatever u want to redirect);
}
 
@Override
public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
oauthServer
.tokenKeyAccess("permitAll()")
.checkTokenAccess("isAuthenticated()");
}
 
@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
endpoints.authenticationManager(authenticationManager);
}
}


Set a different context root
In sso-server project application.properties set the context root of the application as shown below.


server.context-path=/sso-server
This is important to make sure cookie are for /sso-server domain not localhost.

create an api to expose-->
@GetMapping("/user/me")
public Principal user(Principal principal) {
return principal;
}


------------
Now create app1 ClientApplication

Enabling SSO
To enable SSO, we have to annotate our application class with EnableOAuth2Sso as shown below.


@EnableOAuth2Sso   // this is main for sso.
@SpringBootApplication
public class App1Application {

	public static void main(String[] args) {
		SpringApplication.run(App1Application.class, args);
	}

}



b)Next, we need to tell where to find SSO server. Create new file application.yml and define following configuration.
server:
    port: 8082
    context-path: /app1
security:
  basic:
    enabled: false
  oauth2:
    client:
      clientId: foo
      clientSecret: bar
      accessTokenUri: http://localhost:8080/sso-server/oauth/token
      userAuthorizationUri: http://localhost:8080/sso-server/oauth/authorize
    resource:
      userInfoUri: http://localhost:8080/sso-server/user/me


c)Create a index.html

HIII this is appp1

d)We have to define its mapping. Make App1Application extend WebMvcConfigurerAdapter and override addViewControllers as shown here.

package com.sso;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

@EnableOAuth2Sso
@SpringBootApplication
public class App1Application extends WebMvcConfigurerAdapter{

	public static void main(String[] args) {
		SpringApplication.run(App1Application.class, args);
	}

	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
	registry.addViewController("/").setViewName("index"); //redirect any request to index.html
	}
}



==================================================================================================================================
sso with Github-->

In this we dont need a authorization server as it is a third party.

add dependency-->
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>jquery</artifactId>
	<version>3.4.1</version>
</dependency>
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>bootstrap</artifactId>
	<version>4.3.1</version>
</dependency>
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>webjars-locator-core</artifactId>
</dependency>
The final dependency is the webjars "locator" which is provided as a library by the webjars site. Spring can use the locator to locate static assets in webjars without needing to know the exact versions (hence the versionless /webjars/** links in the index.html). The webjar locator is activated by default in a Spring Boot app, as long as you don’t switch off the MVC autoconfiguration.We can explicitly and easily manage the client-side dependencies in JVM-based web applications

With those changes in place, you should have a nice looking home page for your app.

What are client-side dependencies?
Dependencies mean the libraries that are required to make the webpage work. It helps in dealing with complex projects. It also allows us to keep track of and update libraries faster and easier. It is also called a package because it is a collection of libraries.


<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

To use GitHub’s OAuth 2.0 authentication system for login, you must first Add a new GitHub app.

Select "New OAuth App" and then the "Register a new OAuth application" page is presented. Enter an app name and description. Then, enter your app’s home page, which should be http://localhost:8080, in this case. Finally, indicate the Authorization callback URL as http://localhost:8080/login/oauth2/code/github and click Register Application.

The OAuth redirect URI is the path in the application that the end-user’s user-agent is redirected back to after they have authenticated with GitHub and have granted access to the application on the Authorize application page.

The default redirect URI template is {baseUrl}/login/oauth2/code/{registrationId}. The registrationId is a unique identifier for the ClientRegistration.

 Configure Spring OAuth2 Properties for GitHub
Next, update your Spring Boot configuration file (application.yml). Specify the following properties for OAuth2 authentication with GitHub:

spring:
  security:
    oauth2:
      client:
        registration:
          github:
            clientId: fe0087b140fe7b2df3a1                             //these when u created your app
            clientSecret: 945f45e8ce3dbc26e8924cca11b184afcac82e55
# ...


Code Custom OAuth User and OAuth User Service Classes

package net.codejava;
 
import java.util.Collection;
import java.util.Map;
 
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.core.user.OAuth2User;
 
public class CustomOAuth2User implements OAuth2User {
 
    private OAuth2User oauth2User;
     
    public CustomeOAuth2User(OAuth2User oauth2User) {
        this.oauth2User = oauth2User;
    }
 
    @Override
    public Map<String, Object> getAttributes() {
        return oauth2User.getAttributes();
    }
 
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return oauth2User.getAuthorities();
    }
 
    @Override
    public String getName() {
        return oauth2User.getAttribute("name");
    }
 
}


@Service
public class CustomOAuth2UserService extends DefaultOAuth2UserService  {
 
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User user =  super.loadUser(userRequest);
        return new CustomOAuth2User(user);
    }
 
}

Here, we override the loadUser() method which will be called by Spring OAuth2 upon successful authentication, and it returns a new CustomOAuth2User object.


4)Configure Spring Security for OAuth2 Authentication
To integrate single sign on with GitHub with traditional username and password login, update configuration for Spring security as follows:


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/", "/login").permitAll()
            .anyRequest().authenticated()
            .and()
            .formLogin().permitAll()
                .loginPage("/login")
            .and()
            .oauth2Login()
                .loginPage("/login")
                .userInfoEndpoint()
                    .userService(userService) //this is our end point where we get oauth2 user details
            .and()
            .logout().logoutSuccessUrl("/").permitAll().csrf(c -> c
	                            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))
								//The method withHttpOnlyFalse allows jquery/angular to read XSRF cookie. Make sure that Angular makes XHR request with withCreddentials flag set to true.
	           .exceptionHandling(e -> e
                .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED));
    }
     
    @Autowired
    private CustomOAuth2UserService userService;
}

Pay attention to code snippet that configures OAuth2 login:
http.oauth2Login()
    .loginPage("/login")
    .userInfoEndpoint()
        .userService(userService)
		
		
		
		
		
		set this in index.html
		$.ajaxSetup({
  beforeSend : function(xhr, settings) {
    if (settings.type == 'POST' || settings.type == 'PUT'
        || settings.type == 'DELETE') {
      if (!(/^http:.*/.test(settings.url) || /^https:.*/
        .test(settings.url))) {
        // Only send the token to relative URLs i.e. locally.
        xhr.setRequestHeader("X-XSRF-TOKEN",
          Cookies.get('XSRF-TOKEN'));
      }
    }
  }
});
		
		
		
		
		
The app you just wrote, in OAuth 2.0 terms, is a Client Application, and it uses the authorization code grant to obtain an access token from GitHub (the Authorization Server).

It then uses the access token to ask GitHub for some personal details (only what you permitted it to do), including your login ID and your name. In this phase, GitHub is acting as a Resource Server, decoding the token that you send and checking if it gives the app permission to access the user’s details. If that process is successful, the app inserts the user details into the Spring Security context so that you are authenticated.

If you look in the browser tools (F12 on Chrome or Firefox) and follow the network traffic for all the hops, you will see the redirects back and forth with GitHub, and finally you’ll land back on the home page with a new Set-Cookie header. This cookie (JSESSIONID by default) is a token for your authentication details for Spring (or any servlet-based) applications.

So we have a secure application, in the sense that to see any content a user has to authenticate with an external provider (GitHub).



lot of things in this refer-->
https://spring.io/guides/tutorials/spring-boot-oauth2/#_social_login_manual


==============================================================
Example-->

1)lets override by default configuration of security in boot lets use our own username/password by INMEMORY AUTHENTICATION.


@Configuration                          //for configuration class
@EnableWebSecurity                      //enable web security
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {     //descrption is below

@Bean                                                                     //for already described bean and override it.
public UserDetailsService userDetailsService()
{
InMemoryUserDetailsManager usd = new /// class extends user details service for in memory authentication

//creating user

UserDetails user =User.withUsername("//").password("//").authorities("//").build();
usd.createUser(user);

return usd;
}
}
======================================================
Jdbc simple-->

@Configuration
@EnableWebSecurity(debug=true)//to print security logs.
public class SecurityConfig extends WebSecurityConfigurerAdapter {

@Autowired
  DataSource dataSource;

  @Autowired
  public void configAuthentication(AuthenticationManagerBuilder auth) throws Exception {
    auth.jdbcAuthentication().dataSource(dataSource)
        .usersByUsernameQuery("select username,CONCAT('{noop}',password),true from 
public.\"Users\" where username=?")
        .authoritiesByUsernameQuery("select username,role from public.\"Users\" where 
username=?");
}
...
=======================================================
simple custom login --->

@EnableWebSecurity
public class EmployeeSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/resources/**");                      //for static resources we dont need checking
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
       http.authorizeRequests().antMatchers("/admin/**").hasRole("ADMIN").antMatchers("/user/**").hasRole("USER")
				.antMatchers("/**").permitAll().and().formLogin()
				.loginPage("/signin")             //this is custom login page
				.loginProcessingUrl("/dologin")   //this is the url where we submit userame password.
				.defaultSuccessUrl("/user/index")				
				.and().csrf().disable();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder authenticationMgr) throws Exception {
        authenticationMgr.inMemoryAuthentication().withUser("employee").password("employee")
            .authorities("ROLE_USER").and().withUser("javainuse").password("javainuse")
            .authorities("ROLE_USER", "ROLE_ADMIN");
    }

}
'
any method annotated with @Autowired is a config method. It is called on bean instantiation after field injection is done. The arguments of the method are injected into the method on calling.


2)make a controller for /signin and return a html.

 <form id="login-form" class="form" th:action="@{/dologin}" action="#" method="post">   //use your dynamic otherwise 404
                        
                            <h3 class="text-center text-info">Login</h3>
                            
                            <div th:if="${param.error}" class="alert alert-danger">    //on any error spring redirect back to signin with ?error
                            </div>
                            
                             <div th:if="${param.logout}" class="alert alert-success">  //on logout this param will come ?logout
                            	You have been logged out
                            </div>
                            
                             <div th:if="${param.change}" class="alert alert-success">
                            	<p th:text="${param.change}"></p>
                            </div>
                            
                            
                            
                            
                            <div class="form-group">
                                <label for="username" class="text-info">Username:</label><br>
                                <input type="text" name="username" id="username" class="form-control">
                            </div>
                            
                            
                            <div class="form-group">
                                <label for="password" class="text-info">Password:</label><br>
                                <input type="password" name="password" id="password" class="form-control">
                            </div>
                            
                            
                            
                            <div class="form-group">
                                <label for="remember-me" class="text-info"><span>Remember me</span> <span><input id="remember-me" name="remember-me" type="checkbox"></span></label><br>
                                <input type="submit" name="submit" class="btn btn-info btn-md" value="submit">
                            </div>
                            
                            <div id="register-link" class="text-right">
                                <a href="/signup/" class="text-info">Register here</a>
                            </div>
                            
                            <div class="container text-center">
                            
                            
                            <a th:href="@{/forgot}" > Forgot Password ?</a>
                            
                            
                            </div>
                          
                            
                        </form>

========================================================================================================
Custom Authentication handeler--->

Add a new custom AuthenticationSuccessHandler which will do the redirection based on the roles. So the user javainuse will be redirected to the add new employee page while the user employee will be redirected to the welcome page on login.


@Component
public class EmployeeAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

	private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

	@Override
	public void onAuthenticationSuccess(HttpServletRequest arg0, HttpServletResponse arg1,
			Authentication authentication) throws IOException, ServletException {

		boolean hasUserRole = false;
		boolean hasAdminRole = false;
		Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();  //after authentication
		for (GrantedAuthority grantedAuthority : authorities) {
			if (grantedAuthority.getAuthority().equals("ROLE_USER")) {
				hasUserRole = true;
				break;
			} else if (grantedAuthority.getAuthority().equals("ROLE_ADMIN")) {
				hasAdminRole = true;
				break;
			}
		}

		if (hasUserRole) {
			redirectStrategy.sendRedirect(arg0, arg1, "/welcome");
		} else if (hasAdminRole) {
			redirectStrategy.sendRedirect(arg0, arg1, "/addNewEmployee");
		} else {
			throw new IllegalStateException();
		}
	}

}



@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().antMatchers("/").permitAll().antMatchers("/welcome").hasAnyRole("USER", "ADMIN")
				.antMatchers("/getEmployees").hasAnyRole("USER", "ADMIN").antMatchers("/addNewEmployee")
				.hasAnyRole("ADMIN").anyRequest().authenticated()
				.and().formLogin().successHandler(successHandler)              //atttaching it here.
				.loginPage("/login").permitAll().and().logout().permitAll();

		http.csrf().disable();
	}

========================================================================================================
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
      .anyRequest().authenticated()
      .and().httpBasic();
}

equivalent to-->

<http>
    <intercept-url pattern="/**" access="isAuthenticated()"/>
    <form-login />
    <http-basic />
</http>
====================================================

2)spring security with JPA/mysql/DAOPROVIDER.


i)Code User class
To use Spring Data JPA, we need to code a model class that maps with the users table in the database. So create the User class with the following code:

package net.codejava;
 
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
 
@Entity
@Table(name = "users")
public class User {
 
    @Id
    @Column(name = "user_id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 
    private String username;
    private String password;
    private String role;
    private boolean enabled;
 
    // getters and setters are not shown for brevity
 
}

ii)create the UserRepository interface with the following code:

package net.codejava;
 
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
 
public interface UserRepository extends CrudRepository<User, Long> {
 
    @Query("SELECT u FROM User u WHERE u.username = :username")
    public User getUserByUsername(@Param("username") String username);
}

And we declare the getUserByUsername() method with an embedded query to select user details by username. Note that this method returns a single User object if username found, whereas the JPA’s convention method returns a List collection. So we declare this method for convenience.


iii)Implement UserDetails
Next, we need to create a class that implements the UserDetails interface as required by Spring Security. So create the MyUserDetails class with the following code:

public class MyUserDetails implements UserDetails {
 
    private User user;
     
    public MyUserDetails(User user) {
        this.user = user;
    }
 
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        SimpleGrantedAuthority authority = new SimpleGrantedAuthority(user.getRole());
        return Arrays.asList(authority);
    }
 
    @Override
    public String getPassword() {
        return user.getPassword();
    }
 
    @Override
    public String getUsername() {
        return user.getUsername();
    }
 
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
 
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
 
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
 
    @Override
    public boolean isEnabled() {
        return true;
    }
 
}

iv)Implement UserDetailsService
For Spring Security authentication using JPA and Hibernate, we need to implement the UserDetailsService interface by the following class:

public class UserDetailsServiceImpl implements UserDetailsService {
 
    @Autowired
    private UserRepository userRepository;
     
    @Override
    public UserDetails loadUserByUsername(String username)
            throws UsernameNotFoundException {
        User user = userRepository.getUserByUsername(username);
         
        if (user == null) {
            throw new UsernameNotFoundException("Could not find user");
        }
         
        return new MyUserDetails(user);
    }
 
}

v)Configure authentication provider and HTTP security
Finally, we connect all the pieces together by coding a Spring Security configuration class WebSecurityConfig with the following code:

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
 
    @Bean
    public UserDetailsService userDetailsService() {
        return new UserDetailsServiceImpl();                        /////setting our user detail service
    } 
     
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {                ///setting password encoder
        return new BCryptPasswordEncoder();
    }
     
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService());                     ///setting all these items in our provider
        authProvider.setPasswordEncoder(passwordEncoder());
         
        return authProvider;
    }
 
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());                       //updating our provider
    }
 
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .formLogin().permitAll()
            .and()
            .logout().permitAll();
    }
} 


ote that you must use the @Configuration and @EnableWebSecurity annotations for this class. To use Spring security with Spring Data JPA and Hibernate, we need to supply a DaoAuthenticationProvider which requires UserDetailsService and PasswordEncoder.
And in the configure(HttpSecurity) method, we specify that all requests must be authenticated (users must login), and use the default login and logout configuration provided by Spring Security. In case you want to use your own login page, refer to this guide.


vi)at last

@SpringBootApplication
@EnableJpaRepositories                                 /////dont forget to use this...
public class SpringSecurityJpaApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringSecurityJpaApplication.class, args);
	}

}






$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

========================================================================================================
-------------------------------------------------------------------------------------------------------------------------------------------
For ldap-->https://www.youtube.com/watch?v=-wDUChgvYgU&list=PLqq-6Pq4lTTYTEooakHchTGglSvkZAjnE&index=9

2)JWT----json web tokens..mainly used in microservices.
it is used between two parties to communicate properly.

lets we used to access a page from one party to another than we have to tell them who u are?

so why we use jwt?

if we have one monolothic server than we dont need it we can just do it by session id?

but now a days we have many servers so how to tell other servers this is user is logged in and already in session? here come jwt.

so in this we are returning jsessionid we are returning user information in json payload.known as signature.

so every time we r using jwt and sever is not saving these details.....check and authenticate.


Structure of jwt?
What is the JSON Web Token structure?
JSON Web Tokens consist of three parts separated by dots (.), which are:

Header
Payload
Signature


Therefore, a JWT typically looks like the following.
xxxxx.yyyyy.zzzzz


Header--->
The header typically consists of two parts: the type of the token, which is JWT, and the hashing algorithm being used, such as HMAC SHA256 or RSA.
For example:
{
  "alg": "HS256",
  "typ": "JWT"
}
Then, this JSON is Base64Url encoded to form the first part of the JWT.


-----------------------------------


Payload--->
The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: reserved, public, and private claims.

Reserved claims: These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others.

Notice that the claim names are only three characters long as JWT is meant to be compact.

Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace.

Private claims: These are the custom claims created to share information between parties that agree on using them.
An example of payload could be:

{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}

The payload is then Base64Url encoded to form the second part of the JSON Web Token.


--------------------------------------


Signature----->



To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.
For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
  
  
The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn’t changed along the way. Putting all together
The output is three Base64 strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.
The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret. Encoded JWT

-------------------------------
signature part is main otherwise anyone can steal data from token...so signature is only which can server understand no one else.

this is encoded,decoded by key which only server has...and the alogrithim name shared in header.

so flow-->user authenticates,than server create jwt for further interaction on different servers.
so jwt is used only for authorization.

everytime client has to pass it in http header.

jwt should not be use alone can be stole by anothers...so mainly used by oauth.This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.

Single Sign On is a feature that widely uses JWT nowadays, because of its small overhead and its ability to be easily used across different domains.
This is a stateless authentication mechanism as the user state is never saved in server memory. The server’s protected routes will check for a valid JWT in the Authorization header, and if it’s present, the user will be allowed to access protected resources. As JWTs are self-contained, all the necessary information is there, reducing the need to query the database multiple times.


JWT Authentication flow is very simple
User obtains Refresh and Access tokens by providing credentials to the Authorization server
User sends Access token with each request to access protected API resource
Access token is signed and contains user identity (e.g. user id) and authorization claims.



Example-->

i)create a new api authentication endpoint.
ii)examine every request for valid jwt and than authorize.

first add two dependency..
<!-- https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>                 //for json
    <version>2.3.1</version>
</dependency>

<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.10.7</version>
    <scope>runtime</scope>                                          //for json web token
</dependency>


iii)we will continue our old project to authenticate..

just extend some classes extra and add them.


The JwtTokenFilter filter is applied to each API (/**) with exception of the signin token endpoint (/users/signin) and singup endpoint (/users/signup).
if we added...our extra page.

This filter has the following responsibilities:
Check for access token in Authorization header. If Access token is found in the header, delegate authentication to JwtTokenProvider otherwise throw authentication exception

Invokes success or failure strategies based on the outcome of authentication process performed by JwtTokenProvider.

Spring Security and JWT Configuration
We will be configuring Spring Security and JWT for performing 2 operations-

Generating JWT - Expose a POST API with mapping /authenticate. On passing correct username and password it will generate a JSON Web Token(JWT)

Validating JWT - If user tries to access GET API with mapping /hello. It will allow access only if request has a valid JSON Web Token(JWT)

flow--->

1)client send request to /authenticate post it will check request has token to jwatrequestFilter.

a)if yes than ok else to jwtAUthenticationController with same mapping to generate token.

2)jwtAUthenticationController validate username/password with authenticte() method. take help ok manager and jpa.

3)if username/password true jwtAUthenticationController calls jwtTokenUtil for generate token else throw exception.and return a valid token.

4)now user append this token in every url which is valiadte by filter.


-------------------------------------------------
a)first we create util to generate token.The JwtTokenUtil is responsible for performing JWT operations like creation and validation.It makes use of the io.jsonwebtoken.Jwts for achieving this.

@Component
public class JwtTokenUtil implements Serializable {

	private static final long serialVersionUID = -2550185165626007488L;

	public static final long JWT_TOKEN_VALIDITY = 5 * 60 * 60;   //setting validity ok token

	@Value("${jwt.secret}")                                      //value is used to fetch value from properties file.
	                                                             //jwt.secret=javainuse
	private String secret;

	//retrieve username from jwt token
	public String getUsernameFromToken(String token) {
		return getClaimFromToken(token, Claims::getSubject);
	}

	//retrieve expiration date from jwt token
	public Date getExpirationDateFromToken(String token) {
		return getClaimFromToken(token, Claims::getExpiration);
	}

	public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
		final Claims claims = getAllClaimsFromToken(token);
		return claimsResolver.apply(claims);
	}
    //for retrieveing any information from token we will need the secret key
	private Claims getAllClaimsFromToken(String token) {
		return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();   //using key
	}

	//check if the token has expired
	private Boolean isTokenExpired(String token) {
		final Date expiration = getExpirationDateFromToken(token);
		return expiration.before(new Date());
	}

	//generate token for user
	public String generateToken(UserDetails userDetails) {
		Map<String, Object> claims = new HashMap<>();                //our claims is empty here.
		return doGenerateToken(claims, userDetails.getUsername());
	}

	//while creating the token -
	//1. Define  claims of the token, like Issuer, Expiration, Subject, and the ID
	//2. Sign the JWT using the HS512 algorithm and secret key.
	//3. According to JWS Compact Serialization(https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-3.1)
	//   compaction of the JWT to a URL-safe string 
	private String doGenerateToken(Map<String, Object> claims, String subject) {

		return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis()))
				.setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY * 1000))
				.signWith(SignatureAlgorithm.HS512, secret).compact();
	}

	//validate token
	public Boolean validateToken(String token, UserDetails userDetails) {
		final String username = getUsernameFromToken(token);
		return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
	}
	
	
}
-------------------------------------------------------------------------------------------------------
b)JwtAuthenticationController-->
Expose a POST API /authenticate using the JwtAuthenticationController. The POST API gets username and password in the body- Using Spring Authentication Manager we authenticate the username and password.If the credentials are valid, a JWT token is created using the JWTTokenUtil and provided to the client.


@RestController
@CrossOrigin  //CORS” stands for Cross-Origin Resource Sharing. It allows you to make requests from one website to another website                   in the browser, which is normally prohibited by another browser policy called the Same-Origin Policy (SOP).

public class JWTAuthenticationController {

	@Autowired
	private AuthenticationManager authenticationManager;

	@Autowired
	private JwtTokenUtil jwtTokenUtil;

	@Autowired
	private MyUserDetailService userDetailsService;  //this is we create before using jpa.

	@RequestMapping(value = "/authenticate", method = RequestMethod.POST)
	public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {

		authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());

		final UserDetails userDetails = userDetailsService
				.loadUserByUsername(authenticationRequest.getUsername());

		final String token = jwtTokenUtil.generateToken(userDetails);    //

		return ResponseEntity.ok(new JwtResponse(token));
	}

	private void authenticate(String username, String password) throws Exception {
		try {
			authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));//authenticating not authorizing
		} catch (DisabledException e) {
			throw new Exception("USER_DISABLED", e);
		} catch (BadCredentialsException e) {
			throw new Exception("INVALID_CREDENTIALS", e);
		}
	}
}
--------------------------------
c)JwtRequest
This class is required for storing the username and password we recieve from the client.

public class JwtRequest implements Serializable {

	private static final long serialVersionUID = 5926468583005150707L;
	
	private String username;
	private String password;
	
	//getters and setters.
-----------------------------------
d)JwtResponse

This is class is required for creating a response containing the JWT to be returned to the user.

public class JwtResponse implements Serializable {

	private static final long serialVersionUID = -8091879091924046844L;
	private final String jwttoken;

	public JwtResponse(String jwttoken) {
		this.jwttoken = jwttoken;
	}
	
-----------------------------------------
e)JwtRequestFilter
The JwtRequestFilter extends the Spring Web Filter OncePerRequestFilter class. For any incoming request this Filter class gets executed. It checks if the request has a valid JWT token. If it has a valid JWT Token then it sets the Authentication in the context, to specify that the current user is authenticated.

public class JwtRequestFilter extends OncePerRequestFilter {

	@Autowired
	private MyUserDetailService myUserDetailService;

	@Autowired
	private JwtTokenUtil jwtTokenUtil;

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
			throws ServletException, IOException {

		final String requestTokenHeader = request.getHeader("Authorization");

		String username = null;
		String jwtToken = null;
		// JWT Token is in the form "Bearer token". Remove Bearer word and get
		// only the Token
		if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {
			jwtToken = requestTokenHeader.substring(7);
			try {
				username = jwtTokenUtil.getUsernameFromToken(jwtToken);
			} catch (IllegalArgumentException e) {
				System.out.println("Unable to get JWT Token");
			} catch (ExpiredJwtException e) {
				System.out.println("JWT Token has expired");
			}
		} else {
			logger.warn("JWT Token does not begin with Bearer String");
		}

		// Once we get the token validate it.
		if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

			UserDetails userDetails = this.myUserDetailService.loadUserByUsername(username);

			// if token is valid configure Spring Security to manually set
			// authentication
			if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {

				UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
						userDetails, null, userDetails.getAuthorities());  //creating token on authorities.
				usernamePasswordAuthenticationToken
						.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
				// After setting the Authentication in the context, we specify
				// that the current user is authenticated. So it passes the
				// Spring Security Configurations successfully.
				SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
			}
		}
		chain.doFilter(request, response);
	}

}

---------------------------------------------------------------------------------------------------------------------------

e)JwtAuthenticationEntryPoint
This class will extend Spring's AuthenticationEntryPoint class and override its method commence. It rejects every unauthenticated request and send error code 401

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable {

	private static final long serialVersionUID = -7858869558953243875L;

	@Override
	public void commence(HttpServletRequest request, HttpServletResponse response,
			AuthenticationException authException) throws IOException {

		response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
	}
}

------------------------------------------------------------
f)@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)//EnableGlobalMethodSecurity provides AOP security on methods. Some of the annotations that it provides are PreAuthorize, PostAuthorize. 
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	@Autowired
	private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

	@Autowired
	private MyUserDetailService jwtUserDetailsService;

	@Autowired
	private JwtRequestFilter jwtRequestFilter;

	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		// configure AuthenticationManager so that it knows from where to load
		// user for matching credentials
		 auth.userDetailsService(jwtUserDetailsService).passwordEncoder(passwordEncoder());
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
	}

	@Bean
	@Override
	public AuthenticationManager authenticationManagerBean() throws Exception {
		return super.authenticationManagerBean();
	}

	@Override
	protected void configure(HttpSecurity httpSecurity) throws Exception {
		// We don't need CSRF for this example
		httpSecurity.csrf().disable()
				// dont authenticate this particular request
				.authorizeRequests().antMatchers("/authenticate").permitAll().
				// all other requests need to be authenticated
				anyRequest().authenticated().and().
				// make sure we use stateless session; session won't be used to
				// store user's state.
				exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().sessionManagement()
				.sessionCreationPolicy(SessionCreationPolicy.STATELESS);

		// Add a filter to validate the tokens with every request
		httpSecurity.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
	}
}

---------------------------------------------------------------------------------------------------------------------------
Another implementation of Jwt

1)we will create two filter one for validate and one for create token.
validate we wil append before authentication filter if token is there we will not authenticate..create a user on token and append it authentication.
we will create token for new authenticated user after authentication.

public static final String JWT_KEY = "jxgEQeXHuPq8VdbyYFNkANdudQ53YUn4";  //we will use it for signature.
public static final String JWT_HEADER = "Authorization";

here is validator--->

public class JWTTokenValidatorFilter extends OncePerRequestFilter {

	
	@Override
	public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		String jwt = request.getHeader(SecurityConstants.JWT_HEADER);  //validating
		if (null != jwt) {
			try {
				SecretKey key = Keys.hmacShaKeyFor(
						SecurityConstants.JWT_KEY.getBytes(StandardCharsets.UTF_8)); //our secret key
				
				Claims claims = Jwts.parserBuilder()
						.setSigningKey(key)  ///using aour key to decode
						.build()
						.parseClaimsJws(jwt)               parsing claims if token present if not valid throw exception.
						.getBody();
				String username = String.valueOf(claims.get("username"));
				String authorities = (String) claims.get("authorities");
				Authentication auth = new UsernamePasswordAuthenticationToken(username,null,
						AuthorityUtils.commaSeparatedStringToAuthorityList(authorities));  //creating our authentication object
				SecurityContextHolder.getContext().setAuthentication(auth);                //setting authentication no need to hit database.
			}catch (Exception e) {
				throw new BadCredentialsException("Invalid Token received!");
			}
			
		}
		chain.doFilter(request, response);
	}

	
	  @Override protected boolean shouldNotFilter(HttpServletRequest request) {
	  return request.getServletPath().equals("/login"); }  ///it will not check on login
	 
	
}



Here is our Creator---->

public class JWTTokenGeneratorFilter extends OncePerRequestFilter {

	
	@Override
	public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (null != authentication) {   //after authentication so we will check object
			SecretKey key = Keys.hmacShaKeyFor(SecurityConstants.JWT_KEY.getBytes(StandardCharsets.UTF_8));   //our key
			String jwt = Jwts.builder().setIssuer("Eazy Bank").setSubject("JWT Token")
						.claim("username", authentication.getName())
					  .claim("authorities", populateAuthorities(authentication.getAuthorities()))  //setting claims
					  .setIssuedAt(new Date())
					.setExpiration(new Date((new Date()).getTime() + 3000000000))  //expiration time
					.signWith(key).compact();                           //creating signature
			response.setHeader(SecurityConstants.JWT_HEADER, jwt);      //seting it in response header
		}

		chain.doFilter(request, response);
	}

	@Override
	protected boolean shouldNotFilter(HttpServletRequest request) {
		return !request.getServletPath().equals("/login");        it will not call for this
	}
	
	private String populateAuthorities(Collection<? extends GrantedAuthority> collection) {
		Set<String> authoritiesSet = new HashSet<>();
        for (GrantedAuthority authority : collection) {
        	authoritiesSet.add(authority.getAuthority());
        }
        return String.join(",", authoritiesSet);
	}
}


third main is spring config--->


@Override
	protected void configure(HttpSecurity http) throws Exception {

		http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().
		cors().configurationSource(new CorsConfigurationSource() {
			@Override
			public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
				CorsConfiguration config = new CorsConfiguration();
				config.setAllowedOrigins(Collections.singletonList("http://localhost:4200"));
				config.setAllowedMethods(Collections.singletonList("*"));
				config.setAllowCredentials(true);
				config.setAllowedHeaders(Collections.singletonList("*"));
				config.setExposedHeaders(Arrays.asList("Authorization")); ///allowing it from other origions
				config.setMaxAge(3600L);
				return config;
			}
		}).and().csrf().disable()
				.addFilterBefore(new JWTTokenValidatorFilter(), BasicAuthenticationFilter.class)  //validating it before authorizing any request
				.addFilterAfter(new JWTTokenGeneratorFilter(), BasicAuthenticationFilter.class)   //if authenticated than create token
				.authorizeRequests()
				.antMatchers("/myAccount").hasRole("USER")
				.antMatchers("/myBalance").hasAnyRole("USER","ADMIN")
				.antMatchers("/myLoans").hasRole("ROOT")
				.antMatchers("/myCards").hasAnyRole("USER","ADMIN")
				.antMatchers("/user").authenticated()
				.antMatchers("/notices").permitAll()
				.antMatchers("/contact").permitAll().and().httpBasic();
	}


====================================================================================================================================================
FOR MVC jAVA BASED--->
https://docs.spring.io/spring-security/site/docs/4.0.4.RELEASE/reference/html/jc.html

Java Configuration and Form Login
You might be wondering where the login form came from when you were prompted to log in, since we made no mention of any HTML files or JSPs. Since Spring Security’s default configuration does not explicitly set a URL for the login page, Spring Security generates one automatically, based on the features that are enabled and using standard values for the URL which processes the submitted login, the default target URL the user will be sent to after logging in and so on.

While the automatically generated log in page is convenient to get up and running quickly, most applications will want to provide their own log in page. To do so we can update our configuration as seen below:

protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.loginPage("/login") 
			.permitAll();        
}

The updated configuration specifies the location of the log in page.



We must grant all users (i.e. unauthenticated users) access to our log in page. The formLogin().permitAll() method allows granting access to all users for all URLs associated with form based log in.

An example log in page implemented with JSPs for our current configuration can be seen below:

[Note]
The login page below represents our current configuration. We could easily update our configuration if some of the defaults do not meet our needs.

<c:url value="/login" var="loginUrl"/>
<form action="${loginUrl}" method="post">       1
	<c:if test="${param.error != null}">        2
		<p>
			Invalid username and password.
		</p>
	</c:if>
	<c:if test="${param.logout != null}">       3
		<p>
			You have been logged out.
		</p>
	</c:if>
	<p>
		<label for="username">Username</label>
		<input type="text" id="username" name="username"/>	4
	</p>
	<p>
		<label for="password">Password</label>
		<input type="password" id="password" name="password"/>	5
	</p>
	<input type="hidden"                        6
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/>
	<button type="submit" class="btn">Log in</button>
</form>


A POST to the /login URL will attempt to authenticate the user


If the query parameter error exists, authentication was attempted and failed


If the query parameter logout exists, the user was successfully logged out


The username must be present as the HTTP parameter named username


The password must be present as the HTTP parameter named password

---------------------------------------------------------------------------------------------------------------------

Authorize Requests
Our examples have only required users to be authenticated and have done so for every URL in our application. We can specify custom requirements for our URLs by adding multiple children to our http.authorizeRequests() method. For example:

protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()                                                                1
			.antMatchers("/resources/**", "/signup", "/about").permitAll()                  2
			.antMatchers("/admin/**").hasRole("ADMIN")                                      3
			.antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")            4
			.anyRequest().authenticated()                                                   5
			.and()
		// ...
		.formLogin();
}


-------------------------------------------------------------------------------------------------------------------------

Handling Logouts
When using the WebSecurityConfigurerAdapter, logout capabilities are automatically applied. The default is that accessing the URL /logout will log the user out by:

Invalidating the HTTP Session
Cleaning up any RememberMe authentication that was configured
Clearing the SecurityContextHolder
Redirect to /login?success                //////////////////////////////
Similar to configuring login capabilities, however, you also have various options to further customize your logout requirements:

protected void configure(HttpSecurity http) throws Exception {
	http
		.logout()                                                                1
			.logoutUrl("/my/logout")                                                 2
			.logoutSuccessUrl("/my/index")                                           3
			.logoutSuccessHandler(logoutSuccessHandler)                              4
			.invalidateHttpSession(true)                                             5
			.addLogoutHandler(logoutHandler)                                         6
			.deleteCookies(cookieNamesToClear)                                       7
			.and()
		...
}

Provides logout support. This is automatically applied when using WebSecurityConfigurerAdapter.

The URL that triggers log out to occur (default is /logout). If CSRF protection is enabled (default), then the request must also be a POST. For for information, please consult the JavaDoc.

The URL to redirect to after logout has occurred. The default is /login?logout. For for information, please consult the JavaDoc.

Let’s you specify a custom LogoutSuccessHandler. If this is specified, logoutSuccessUrl() is ignored. For for information, please consult the JavaDoc.

Specify whether to invalidate the HttpSession at the time of logout. This is true by default. Configures the SecurityContextLogoutHandler under the covers. For for information, please consult the JavaDoc.

Adds a LogoutHandler. SecurityContextLogoutHandler is added as the last LogoutHandler by default.

Allows specifying the names of cookies to be removed on logout success. This is a shortcut for adding a CookieClearingLogoutHandler explicitly.

deny all is opposite of permit all.

userdetailsmanager------extends------userdetailservice--------extends-------userdetails.
---------------------------------------------------------------------------------------------------------------------
password encoder-->

1)nooppasswordencoder -------> for no encoding.
2)standardpasswordencoder---->use SHA256 encoding.

public StandardPasswordEncoder(CharSequence secret) {   //we can pass secret for more security
		this("SHA-256", secret);
	}
	
3)Bcrypt and Scrypt password Encoder-->both are mostly used now a days using hashing.


---------------------------------------------------------------------------------------------------------------------
when to override  AuthenticationProvider?
when we does not want to go spring flow.
like fingerprint,otp verification etc.we will not use usernamepaswordauthentication token here.


Method level security--->

it will activate by annotation @EnableGlobalMethodSecurity  on config class.
it takes attribue prepostEnabled(//for pre/pst Authorize)= true,securedenabled(//for @Secured),jsr250enabled(//for @RoleAllowed)
it activates two things-->

1)Invocation Authorization-->validate if someone can invoke method on their roles or not.  by @pre/postEnabled etc.

2)Filtering Authorization---->what application can recieve and send to user. by @prefilter/post

@PreAuthorize,@Secured etc.

@preauthorize will check before method and doesnot excute business rule...but post authorize run business logic.


-----------------------------------------------------------------

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers()
            .hsts().disable()
            .frameOptions().mode(Mode.SAMEORIGIN);
    return http.build();
}

The X-Frame-Options HTTP response header can be used to indicate whether or not a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid click-jacking attacks, by ensuring that their content is not embedded into other sites.


There are two possible directives for X-Frame-Options:

X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
Directives
If you specify DENY, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify SAMEORIGIN, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.

DENY
The page cannot be displayed in a frame, regardless of the site attempting to do so.

SAMEORIGIN
The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin

----------------------------------------------------------------------------------------------

When Is the Session Created?
We can control exactly when our session gets created and how Spring Security will interact with it:

always – a session will always be created if one doesn't already exist
ifRequired – a session will be created only if required (default)
never – the framework will never create a session itself but it will use one if it already exists
stateless – no session will be created or used by Spring Security


@Override
protected void configure(HttpSecurity http) throws Exception {
    http.sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
}

---------------------------------------------------------------
HttpSessionRequestCache-->

RequestCache which stores the SavedRequest in the HttpSession. The DefaultSavedRequest class is used as the implementation.

<bean id="httpSessionRequestCache" class="com.amway.security.impl.WebHttpSessionRequestCache">
        <property name="requestMatcher" ref="excludeRedirectUrlRequestMatcher"/>
        <property name="sessionService" ref="sessionService"/>
    </bean>
	
	
	we can use it to exclude some requests from security.
-------------------------------------------------------------
ReviseMVC with everything later.
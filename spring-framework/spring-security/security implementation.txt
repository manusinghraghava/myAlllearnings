this is the sheet i created to learn how to implement spring security without any error.

1)download all depenedency

 <dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
    <version>5.0.0.RELEASE</version>
  </dependency>

  <dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-config</artifactId>
    <version>5.0.0.RELEASE</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.0.2.RELEASE</version>
  </dependency>

  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>5.0.2.RELEASE</version>
  </dependency>

  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>5.2.12.Final</version>
  </dependency>

  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-c3p0</artifactId>
    <version>5.2.12.Final</version>
  </dependency>

  <dependency>
    <groupId>com.mchange</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.5.2</version>
  </dependency>
  
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>6.0.6</version>
  </dependency>
  
  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
  </dependency>

  <dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>javax.servlet.jsp-api</artifactId>
    <version>2.3.1</version>
    <scope>provided</scope>
  </dependency>

  <dependency>
    <groupId>javax.servlet.jsp.jstl</groupId>
    <artifactId>javax.servlet.jsp.jstl-api</artifactId>
    <version>1.2.1</version>
  </dependency>

  <dependency>
    <groupId>taglibs</groupId>
    <artifactId>standard</artifactId>
    <version>1.1.2</version>
  </dependency>

  <dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.0</version>
  </dependency>

2)create web.xml

<?xml version="1.0" encoding="UTF-8"?>  
<!DOCTYPE xml>  
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee  
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"  
         version="3.1">  
          
        <!-- Spring Configuration -->  
        <servlet>  
            <servlet-name>spring</servlet-name>  
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
            <load-on-startup>1</load-on-startup>  
        </servlet>  
        <servlet-mapping>  
            <servlet-name>spring</servlet-name>  
            <url-pattern>/</url-pattern>  
        </servlet-mapping>  
          
        <listener>  
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  
    </listener>  
      
    <filter>  
        <filter-name>springSecurityFilterChain</filter-name>  
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>  
    </filter>  
    <filter-mapping>  
        <filter-name>springSecurityFilterChain</filter-name>  
        <url-pattern>/*</url-pattern>  
    </filter-mapping>  
          
        <context-param>  
            <param-name>contextConfigLocation</param-name>  
            <param-value>  
                /WEB-INF/spring-servlet.xml  
                /WEB-INF/spring-security.xml 
            </param-value>  
        </context-param>  
</web-app>

*) delegatingFilterProxy==>activate spring security

3)create spring-servlet.xml(dispatcher-servlet)

<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns:mvc="http://www.springframework.org/schema/mvc"
xmlns:tx="http://www.springframework.org/schema/tx"  
xmlns:context="http://www.springframework.org/schema/context"  
xsi:schemaLocation="  
http://www.springframework.org/schema/mvc  
http://www.springframework.org/schema/mvc/spring-mvc.xsd  
http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd  
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://www.springframework.org/schema/context   
http://www.springframework.org/schema/context/spring-context.xsd">  
<mvc:annotation-driven />            //to use spring based annotated
<mvc:default-servlet-handler/>       //handling dispatcher
   <context:component-scan base-package="com.manvendra.Controller" />  //spring will check this for controllers and beans
   <context:annotation-config></context:annotation-config>             //not use to declare beans for annotations
   <context:property-placeholder location="classpath*:resources/db.properties" />   //for properties file
   <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  //view resolver
      <property name="prefix" value="/WEB-INF/views/"></property>  
      <property name="suffix" value=".jsp"></property>  
   </bean>
   <!-- Step 1: Define Database Datasource/connection pool -->
	<bean id="dataSource"                                             //database properties
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/manu" />
		<property name="username" value="root" />
		<property name="password" value="MAnv12@3" />
	</bean>
 
	<!-- Step 2: Setup Hibernate session factory -->       
	<bean id="sessionFactory"                        // hibernate properties
		class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="packagesToScan" value="com.manvendra" />    //for entity classes
		<property name="hibernateProperties">
			<props>
				<prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
				<prop key="hbm2ddl.auto">update</prop>
				<prop key="hibernate.show_sql">true</prop>
			</props>
		</property>
	</bean>
    <bean id="userDao" class="com.manvendra.Dao.UserDaoImpl">
		<property name="sessionFactory" ref="sessionFactory" />
	</bean>
	<!-- Step 3: Setup Hibernate transaction manager -->
	<bean id="transactionManager"
		class="org.springframework.orm.hibernate5.HibernateTransactionManager">
		<property name="sessionFactory" ref="sessionFactory" />
	</bean> 
	<tx:annotation-driven/>                                     //activate @transactional
</beans>  


4)spring-security.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"  
    xmlns:beans="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans.xsd  
    http://www.springframework.org/schema/security  
    http://www.springframework.org/schema/security/spring-security.xsd">  
   <http auto-config="true" use-expressions="true">                                   //auto-config makes http basic activate and use-expressions activate internal methods to work
		<intercept-url pattern="/admin**" access="hasRole('Role_user')"/>
		<form-login 
		    login-page="/login"                                               // custom login -page
		    default-target-url="/welcome" 
		    login-processing-url="/j_spring_security_check"                   //main to process login
			authentication-failure-url="/login?error" 
			username-parameter="username"
			password-parameter="password" />
		<logout logout-success-url="/login?logout" />
		<!-- enable csrf protection -->
		<csrf disabled="true"/>
	</http>

	<authentication-manager >
        <authentication-provider user-service-ref="ManuUserService">                 //using user-service ref for authentication provider with bcrypt encoder(handled by s_security)
            <password-encoder ref="bcryptEncoder"/>
        </authentication-provider>
    </authentication-manager>
      
    <beans:bean id="bcryptEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" />    //bcryptencoder provided by springS
    <beans:bean id="ManuUserService" class="com.manvendra.Service.ManuUserService" />
</beans:beans>  

5)now a login page
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<html>
<head>
<title>Login Page</title>
<style>
.error {
	padding: 15px;
	margin-bottom: 20px;
	border: 1px solid transparent;
	border-radius: 4px;
	color: #a94442;
	background-color: #f2dede;
	border-color: #ebccd1;
}

.msg {
	padding: 15px;
	margin-bottom: 20px;
	border: 1px solid transparent;
	border-radius: 4px;
	color: #31708f;
	background-color: #d9edf7;
	border-color: #bce8f1;
}

#login-box {
	width: 300px;
	padding: 20px;
	margin: 100px auto;
	background: #fff;
	-webkit-border-radius: 2px;
	-moz-border-radius: 2px;
	border: 1px solid #000;
}
</style>
</head>
<body onload='document.loginForm.username.focus();'>

	<h1>Spring Security Custom Login Form (XML)</h1>

	<div id="login-box">

		<h2>Login with Username and Password</h2>

		<c:if test="${not empty error}">
			<div class="error">${error}</div>
		</c:if>
		<c:if test="${not empty msg}">
			<div class="msg">${msg}</div>
		</c:if>

		<form name='loginForm'
		  action="<c:url value='j_spring_security_check' />" method='POST'>      // redirecting to sprin-security

		  <table>
			<tr>
				<td>User:</td>
				<td><input type='text' name='username'></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><input type='password' name='password' /></td>
			</tr>
			<tr>
				<td colspan='2'><input name="submit" type="submit"
					value="submit" /></td>
			</tr>
		  </table>
          <span>New user<a href='<c:url value="/register"></c:url>'>REGISTER</a></span>
		  <input type="hidden" name="${_csrf.parameterName}"                                //as csrf is enabled we have to send it with every request
			value="${_csrf.token}" />

		</form>
	</div>

</body>
</html>


7)Registration for new user

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Guru Registration Form</title>
</head>
<body>
<h1>Guru Register Form</h1>
<form action="<c:url value='/register'/>" method="post">
			<table style="with: 50%">
				<tr>
					<td>First Name</td>
					<td><input type="text" name="first_name" /></td>
				</tr>
				<tr>
					<td>Last Name</td>
					<td><input type="text" name="last_name" /></td>
				</tr>
				<tr>
					<td>UserName</td>
					<td><input type="text" name="username" /></td>
				</tr>
					<tr>
					<td>Password</td>
					<td><input type="password" name="password" /></td>
				</tr>
				<tr>
					<td>Reenter Password</td>
					<td><input type="password" name="r_password" /></td>
				</tr>
				<tr>
					<td>Address</td>
					<td><input type="text" name="address" /></td>
				</tr>
				<tr>
					<td>Contact No</td>
					<td><input type="text" name="contact" /></td>
				</tr></table>
			<input type="submit" value="Submit" /></form>
			<input type="hidden" name="${_csrf.parameterName}"
			value="${_csrf.token}" />
</body>
</html>

8)private secure page

<html>  
<head>  
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  
<title>Admin</title>  
</head>  
<body>  
Hello Admin  
</body>  
</html>  

8)Admin.jsp
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%@page session="true"%>
<html>
<body>
	<h1>Title : ${title}</h1>
	<h1>Message : ${message}</h1>

	<c:url value="/j_spring_security_logout" var="logoutUrl" />

	<!-- csrt for log out-->
	<form action="${logoutUrl}" method="post" id="logoutForm">
	  <input type="hidden" 
		name="${_csrf.parameterName}"
		value="${_csrf.token}" />
	</form>
	
	<script>
		function formSubmit() {
			document.getElementById("logoutForm").submit();
		}
	</script>

	<c:if test="${pageContext.request.userPrincipal.name != null}">         //checking is any person authenticated
		<h2>
			Welcome : ${pageContext.request.userPrincipal.name} | <a
				href="javascript:formSubmit()"> Logout</a>
		</h2>
	</c:if>

</body>
</html>

9)Now as we using database to store user information so create two entity classes for user and their authorities

@Entity
@Table(name = "USERS")
public class User {
  @Id
  @Column(name = "USERNAME")
  private String username;

  @Column(name = "PASSWORD", nullable = false)
  private String password;

  @Column(name = "ENABLED", nullable = false)
  private boolean enabled;

  @OneToMany(cascade = CascadeType.ALL, mappedBy = "user")    as user can have many roles so mapped by user as foreign key//cascade to propogate data to sub ones
  private Set<Authorities> authorities = new HashSet<>();

//getter nad setter


@Entity
@Table(name = "AUTHORITIES")
public class Authorities {
  @Id
  @Column(name = "AUTHORITY")
  private String authority;

  @ManyToOne
  @JoinColumn(name = "USERNAME")                                           join to manytoone
  private User user;

//getter and setter  

10)now as we r using database so we have dao and their impleementations

package com.manvendra.Dao;

import java.util.ArrayList;
import java.util.List;

import javax.transaction.Transactional;

import org.hibernate.SessionFactory;


import com.manvendra.models.User;
@Transactional
public class UserDaoImpl implements UserDao {


	private SessionFactory sessionFactory;

	@SuppressWarnings("unchecked")
	public User findByUserName(String username) {

		List<User> users = new ArrayList<User>();

		users = getSessionFactory().getCurrentSession()                        // to get old user
			.createQuery("from User where username=?")
			.setParameter(0, username).list();

		if (users.size() > 0) {
			return users.get(0);
		} else {
			return null;
		}

	}

	public SessionFactory getSessionFactory() {
		return sessionFactory;
	}

	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}

	@Override
	public void saveUser(User user) {
		getSessionFactory().getCurrentSession().save(user);                   // to save new user
		
	}

}



12)Now we r using our user-service-ref to authentication

so create class implementing  UserDetailsService and override loadbyusername method..

package com.manvendra.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.transaction.Transactional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import com.manvendra.Dao.UserDao;
import com.manvendra.models.Authorities;


@Transactional
public class ManuUserService implements UserDetailsService{
	  
    @Autowired
    private UserDao userDao;

	
	public UserDetails loadUserByUsername(String username) 
               throws UsernameNotFoundException {

		com.manvendra.models.User user = userDao.findByUserName(username);
		List<GrantedAuthority> authorities = buildUserAuthority(user.getAuthorities());    converting collection<Authorities> into collection<GrantedAuthority>

		return buildUserForAuthentication(user, authorities);
		

	}

	
	private User buildUserForAuthentication(com.manvendra.models.User user, 
		List<GrantedAuthority> authorities) {
		return new User(user.getUsername(), user.getPassword(), user.isEnabled(),true, true, true, authorities);
	}     /// returning import org.springframework.security.core.userdetails.User;  // not our ones

parametres==>1)username,2)password,3)enabled,4)boolean accountNonExpired,5) boolean credentialsNonExpired,
			6)boolean accountNonLocked,7) Collection<? extends GrantedAuthority> authorities)

	private List<GrantedAuthority> buildUserAuthority(Set<Authorities> userRoles) {

		Set<GrantedAuthority> setAuths = new HashSet<GrantedAuthority>();

		// Build user's authorities
		for (Authorities userRole : userRoles) {
			setAuths.add(new SimpleGrantedAuthority(userRole.getAuthority()));   converting object of authority into simpleGrantedAuthority..
		}

		List<GrantedAuthority> Result = new ArrayList<GrantedAuthority>(setAuths);

		return Result;
	}

	public UserDao getUserDao() {
		return userDao;
	}

	public void setUserDao(UserDao userDao) {
		this.userDao = userDao;
	}

}
//


12)Now Last Controller For handling requests

package com.manvendra.Controller; 

import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import com.manvendra.Dao.UserDao;
import com.manvendra.models.Authorities;
import com.manvendra.models.User;
import com.manvendra.pojo.UserPojo;  
  
@Controller  
public class HomeController {
	@Autowired
	PasswordEncoder encoder;
	@Autowired
    private UserDao userDao;
	@RequestMapping(value = { "/", "/welcome**" }, method = RequestMethod.GET)
	public ModelAndView welcomePage() {

		ModelAndView model = new ModelAndView();
		model.addObject("title", "Spring Security Custom Login Form");
		model.addObject("message", "This is welcome page!");
		model.setViewName("hello");
		return model;

	}
	@RequestMapping(value = { "/register" }, method = RequestMethod.GET)
	public String register() {

		return "register";

	}
	@RequestMapping(value = { "/register" }, method = RequestMethod.POST)
	public String registerUser(@ModelAttribute("UserDao")UserPojo userd) {
		User user = new User();
		user.setUsername(userd.getUsername());
        user.setPassword(encoder.encode(userd.getPassword()));        //bcrypting password before saving matching is handled by spring security
        user.setEnabled(true);
        Set<Authorities> a = new HashSet<>();
        Authorities an = new Authorities();
        an.setAuthority("Role_user");
        an.setUser(user);
        a.add(an);
        user.setAuthorities(a);
        userDao.saveUser(user);
		return "redirect:login";

	}

	@RequestMapping(value = "/admin**", method = RequestMethod.GET)
	public ModelAndView adminPage() {

		ModelAndView model = new ModelAndView();
		model.addObject("title", "Spring Security Custom Login Form");
		model.addObject("message", "This is protected page!");
		model.setViewName("admin");

		return model;

	}

	//Spring Security see this :
	@RequestMapping(value = "/login", method = RequestMethod.GET)
	public ModelAndView login(
		@RequestParam(value = "error", required = false) String error,
		@RequestParam(value = "logout", required = false) String logout) {

		ModelAndView model = new ModelAndView();
		if (error != null) {
			model.addObject("error", "Invalid username and password!");
		}

		if (logout != null) {
			model.addObject("msg", "You've been logged out successfully.");
		}
		model.setViewName("login");

		return model;

	}
} 

NOw we have done spring security dao based now additional features====> 

14)Now we want to do role based login==>

For role based login we used authentication-success-handeler according to name after authentication is successfull handle the target-url according to its role..

we can use spring default authentication-handeler or we can create custom-succeess--handeler

lets create our own success-handeler which extends SimpleUrlAuthenticationSuccessHandler.

if we r using default one than we can 

<form-login 
		    login-page="/login" 
		    default-target-url="/home" 
		    login-processing-url="/j_spring_security_check"
			authentication-failure-url="/login?error" 
			username-parameter="username"
			password-parameter="password"
			authentication-success-handler-ref="simpleUrlAuthenticationSuccessHandler" />

and than
<beans:bean id="simpleUrlAuthenticationSuccessHandler" class="org.springframework.security.web.authentication.**SimpleUrlAuthenticationSuccessHandler**">
     <beans:property name="defaultTargetUrl" value="/"/>
     <beans:property name="targetUrlParameter" value="redirect"/>     /// /spring_security_login?redirect=/item5   useful for redirection
     <beans:property name="useReferer" value="true"/>
</beans:bean>

default-target-url==>will redirect to default-target-url if not any provided
user-referer if true than it will always redirect to referer it is available in header...

Now implementing all

Remember User is already authenticated through database we r just redirecting it to default-target-url according to its role

package com.manvendra.Security;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.DefaultRedirectStrategy;
import org.springframework.security.web.RedirectStrategy;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;

public class ManuAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {
	
	private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();     //it has handle method to redirect target-url..
	
	 @Override  // for handle urls
	    protected void handle(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
	            throws IOException {
		  String targetUrl = determineTargetUrl(authentication);
		  
	        if (response.isCommitted()) {
	            System.out.println("Can't redirect");       ///if already committed dont work
	            return;
	        }
	 
	        redirectStrategy.sendRedirect(request, response, targetUrl);
	    }
	 
	    /*
	     * This method extracts the roles of currently logged-in user and returns
	     * appropriate URL according to his/her role.
	     */
	    protected String determineTargetUrl(Authentication authentication) {
	        String url = "";
	 
	        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();           /////extracting all roles through authentication.getAuthorities()
	 
	        List<String> roles = new ArrayList<String>();
	 
	        for (GrantedAuthority a : authorities) {
	            roles.add(a.getAuthority());
	        }
	 
	        if (isAdmin(roles)) {
	            url = "/";
	        } else if (isUser(roles)) {
	            url = "/home";
	        } else {
	            url = "/accessDenied";
	        }
	 
	        return url;
	    }
	 
	    private boolean isUser(List<String> roles) {
	        if (roles.contains("Role_user")) {
	            return true;
	        }
	        return false;
	    }
	 
	    private boolean isAdmin(List<String> roles) {
	        if (roles.contains("Role_admin")) {
	            return true;
	        }
	        return false;
	    }
	
}

NOw as we r getting forbidden error again and again it is not good as programming structure..so it is always good to use your own custom access-denied-handeler

By default, Spring Security has an **ExceptionTranslationFilter** defined which handles exceptions of type AuthenticationException and AccessDeniedException. 
The latter is done through a property called accessDeniedHandler, which uses the AccessDeniedHandlerImpl class.

==>Using an access denied handler(ref) instead of a page has the advantage that we can define custom logic to be executed before redirecting to the 403 page. 
For this, we need to create a class that implements the **AccessDeniedHandler interface** and overrides the handle() method.


Now creating our own custom handeler class for access denied

1)create a jsp
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<body>
	<h1>HTTP Status 403 - Access is denied</h1>
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2836379775501347"
     data-ad-slot="8821506761"
     data-ad-format="auto"
     data-ad-region="mkyongregion"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h2>${msg}</h2>
</body>
</html>

2)Entry of the error page in security.cml inside http tag 

<access-denied-handler error-page="/403" />                            //it will work for all upcoming request in a given http tag..

3)A method inside a controller which will handle access denied or erro request

// for 403 access denied page
	@RequestMapping(value = "/403", method = RequestMethod.GET)
	public ModelAndView accesssDenied(Principal user) {

		ModelAndView model = new ModelAndView();

		if (user != null) {
			model.addObject("msg", "Hi " + user.getName() 
			+ ", you do not have permission to access this page!");
		} else {
			model.addObject("msg", 
			"You do not have permission to access this page!");
		}

		model.setViewName("403");
		return model;

	}

this is the all u can do to control access-denied but if you want to perform some task before going to error page than you can use access-denied-handeler-ref

4)create a custom handeler which implements accessdeniedhandeler Interface and override handle() method..

public class ManuAccessDeniedHandeler implements AccessDeniedHandler {

	@Override
	public void handle(HttpServletRequest request, HttpServletResponse response,
			AccessDeniedException accessDeniedException) throws IOException, ServletException {
		// TODO Auto-generated method stub
		Authentication auth 
        = SecurityContextHolder.getContext().getAuthentication();           //getting current user details
      if (auth != null) {
          System.out.println("User: " + auth.getName() 
            + " attempted to access the protected URL: "
            + request.getRequestURI());
      }

      response.sendRedirect(request.getContextPath() + "/accessDenied");
  }
		
	}

5)Now make a entry into the security.xml file of this bean and refer the bean into the access-denied-handeler-ref.

<beans:bean id="manuAccessDeniedHandeler" class="com.manvendra.Security.ManuAccessDeniedHandeler" />
<access-denied-handler ref ="manuAccessDeniedHandeler" />

So whole flow-->
on not have access-->go to handeler it will do some buisness logic-->redirect to controller with some request-->controller handle the request and sent it to view..

==========================================================================================================================================================================================
Now creating some project work for rest services

1)use <form:errors path=""> tag to show bindingresult of model attribute=======> in path name of model attribute if want to include sub classes than modelattribute.*.

2)@initBinder is used if u dont want to bind some thing with @modelAttribute with its method setDisallowedfields(new String[]{"value1","value2",....n})
and if we want changes on any binding lets take example of date..if date is not in specififormat it will throw error
than in method having @initbinder annotatation and webdatabinder as argument you can use

binder.registercustomeditor(datatype of oldvalue,variable name of old datatype,new editor value ref);

you can create your own custom editor class and pass it in ref..
just extend propertyeditorsupport class and override assetText() method.. and setvalue inside with setValue() method

3)use jsr validator to enable @valid annotation while binding 
jar required-->
a)hibernate-validator
b)validation
c)jboss-loging

than you can use some annotations in pojo to validate binding
@Size(min,max)  //to give size on any attribute betwn min and max
@pattern(regexp="")//to match given pattern
@past work with date if you dant want any future dates to be bind   viceversa @future
@max value of integer must be below this and @min to must bigger this
you can also create custom validations

use messagesource for resource bundle to store error for binding...in a property file

dont follow to forget pattern in property file annotationname.@modelattributename.propertyname=error

If you want to put your website down on any weekday so you should check before every request on a particular day in this case interceptor will be helpful
just easy three steps
a)create class which extends handelerinterceptorAdapter class
b)override boolean preHandle() method.   // write logic inside
c)add the bean in <interceptor> in dispatcher.servlet.xml it will automatically call it.
<interceptors>
<interceptor>
<mapping path="/for specific url u want to put interceptor otherwise work for whole context"/>
<bean===>
</interceptor>
</interceptors>

5)for internalization and localization we also use resourcebundle and just make properties file with name_languagecode and put key value pair inside with basic languages..
to print these value we use
<spring:message code="key">   // to print in value for specific format

and include a localChangeInterceptor Bean in di-spring.xml with <property name="paramname" value="sitelanguage" />

and a bean in same xml with name CookieLocalresolver

dont forget to add two links for same page with?sitelanguage=en or fr

6)same as for theme just change the name of change into theme in bean cookies and interceptor..

7)for handling Exception in Spring we make a method for handle Exception and put @ExceptionHandeler(value=Exception_name.class) and we can return view with some msg save in model..
   BUt it worked on given controller class not work globally on all Controller class..

So to declare Globally==

a)create a class with @ControllerAdvice on above it and put these method in it..and we can also send hhtpStatus by using @responseStatus
b)or use ootb SimpleMappingExceptionResolver and put entry in property ExceptionMapping map>>>>>key --exceptionName     value---Jsp Name
   u can also put defaultErrorview and Logger in property by d.Injection...


8)for json in rest we require jackson jars  and for xml jackson-jaxb

9)Always Remember when we send request from postman we send header ***accept with value in which we want respective format....
10)for backhand we use produces and consumes..

============================================================================================================================================================================================
************************************************************************Spring Security Continue**********************************************************************************
<security:http disable-url-rewriting="true" pattern="/checkout/**" use-expressions="true"  create-session="stateless">
<anonymous enabled="false" />                                           //no anynomous
we can disable url-rewriting also and session disable

Entry-point-ref ==>
A custom AuthenticationEntryPoint can be used to set necessary response headers, content-type, and so on before sending the response back to the client.

The org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint class is a built-in AuthenticationEntryPoint implementation, 
which will get invoked for basic authentication to commence. 
A custom entry point can be created by implementing the org.springframework.security.web.AuthenticationEntryPoint interface. The following is an example implementation:

@Component
public final class CustomAuthenticationEntryPoint implements 
        AuthenticationEntryPoint {
    @Override
    public void commence(final HttpServletRequest request, final 
            HttpServletResponse response, final AuthenticationException 
        authException) throws IOException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
    }
}
When a client accesses resources without authentication...it will show unauthorized error..

Types of entry point

BasicAuthenticationEntryPoint==>Once a user agent is authenticated using BASIC authentication, logout requires that the browser be closed or an unauthorized (401) header be sent. 
The simplest way of achieving the latter is to call the commence(HttpServletRequest, HttpServletResponse, AuthenticationException) method below. 
This will indicate to the browser its credentials are no longer authorized, causing it to prompt the user to login again.

**Main aim BasicAuthenticationEntryPoint is to set **WWW-Authenticate** header to the response.
If WWW-Authenticate is present it will open a popup in window when it is not authenticate which ask username and password..
key and value in header==>
WWW-Authenticate: <type> realm=<realm>
<type>==>
Authentication type. A common type is "Basic".
realm=<realm>
A description of the protected area. If no realm is specified, clients often display a formatted hostname instead.

Example==>
WWW-Authenticate: Basic

WWW-Authenticate: Basic realm="Access to the staging site"

 @Override
    public void commence
      (HttpServletRequest request, HttpServletResponse response, AuthenticationException authEx) 
      throws IOException, ServletException {
        response.addHeader("WWW-Authenticate", "Basic realm="" + getRealmName() + """);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        PrintWriter writer = response.getWriter();
        writer.println("HTTP Status 401 - " + authEx.getMessage());
    }






LoginUrlAuthenticationEntryPoint==>redirect to login page

<b:bean class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
	<b:constructor-arg value="/login"/>
</b:bean>

or we can create our custom by implementing it and override commence

public class AppAuthenticationEntryPoint extends LoginUrlAuthenticationEntryPoint {

    private final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    public AppAuthenticationEntryPoint(final String loginFormUrl) {
        super(loginFormUrl);
    }

    /**
     * Performs the redirect (or forward) to the login form URL.
     */
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {

        // redirect to login page. Use https if forceHttps true
        String redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);
        redirectStrategy.sendRedirect(request, response, redirectUrl);
    }

}


===================================================================================================================================================================================
Request-Matcher===>request-matcher Defines the RequestMatcher strategy used in the FilterChainProxy 
and the beans created by the intercept-url to match incoming requests. 

we can give it in anywhere==>
http==> to match http request
csrf==>to match csrf request where to enable and disable csrf..we have to just give request-matcher-ref...

Creating and implementing==>

Lets make some request Exclude from to be recognised by csrf means csrf not required...

a)<csrf request-matcher-ref="excludeUrlRequestMatcher" />

b)create a bean with this name..

public class ExcludeUrlRequestMatcher implements RequestMatcher
{
	private static final Logger LOG = Logger.getLogger(ExcludeUrlRequestMatcher.class);

	private Set<String> excludeUrlSet;
	private PathMatcher pathMatcher;                                           ///java.uti. use for matching url

	@Override
	public boolean matches(final HttpServletRequest request)
	{
		// Do not match patterns specified in the excludeUrlSet to the servletPath
		for (final String excludeUrl : getExcludeUrlSet())
		{
			if (getPathMatcher().match(excludeUrl, request.getServletPath()))
			{
				// Found an exclude pattern
				return false;
			}
		}

		// Not found an exclude URL that matched therefore ok to proceed
		return true;
	}

	protected Set<String> getExcludeUrlSet()
	{
		return excludeUrlSet;
	}

	@Required
	public void setExcludeUrlSet(final Set<String> excludeUrlSet)
	{
		final Set<String> validUrls = new HashSet<String>();

		// Ensure only valid urls are added to the excludeUrlSet
		for (final String url : excludeUrlSet)
		{
			if (url.charAt(0) == '/')
			{
				validUrls.add(url);
			}
			else
			{
				LOG.warn("Ignoring ExcludeUrl [" + url + "] as it is not valid");
			}
		}

		this.excludeUrlSet = validUrls;
	}

	protected PathMatcher getPathMatcher()
	{
		return pathMatcher;
	}

	@Required
	public void setPathMatcher(final PathMatcher pathMatcher)
	{
		this.pathMatcher = pathMatcher;
	}
}

-->dont forget to add bean===>

<bean id="excludeRedirectUrlRequestMatcher" class="com.gorillagroup.storefront.security.ExcludeUrlRequestMatcher">
	<property name="excludeUrlSet">
		<set>
			<value>.*/guest/.*</value>
			<value>.*/orderConfirmation/.*</value>
			<value>.*/login</value>
			<value>.*/login/checkout</value>
		</set>
	</property>
	<property name="pathMatcher" ref="defaultPathMatcher" />
	</bean>


<beans:bean id="antPathMatcher" class="org.springframework.util.AntPathMatcher"/>

Part of this mapping code has been kindly borrowed from Apache Ant.

The mapping matches URLs using the following rules:
? matches one character
* matches zero or more characters
** matches zero or more directories in a path
{spring:[a-z]+} matches the regexp [a-z]+ as a path variable named "spring"
Examples
com/t?st.jsp — matches com/test.jsp but also com/tast.jsp or com/txst.jsp
com/*.jsp — matches all .jsp files in the com directory
com/**/test.jsp — matches all test.jsp files underneath the com path
org/springframework/**/*.jsp — matches all .jsp files underneath the org/springframework path
org/**/servlet/bla.jsp — matches org/springframework/servlet/bla.jsp but also org/springframework/testing/servlet/bla.jsp and org/servlet/bla.jsp
com/{filename:\\w+}.jsp will match com/test.jsp and assign the value test to the filename variable


Some methods to Remember

I will put a small comparison table here (just to have it somewhere):

Servlet is mapped as /test%3F/* and the application is deployed under /app.

The <space> character has been URL encoded as "+".
The & character has been URL encoded as "%3F".

http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=S%3F+ID?p+1=c+d&p+2=e+f#a

Method              URL-Decoded Result           
----------------------------------------------------
getContextPath()        no      /app
getLocalAddr()                  127.0.0.1
getLocalName()                  30thh.loc
getLocalPort()                  8480
getMethod()                     GET
getPathInfo()           yes     /a?+b
getProtocol()                   HTTP/1.1
getQueryString()        no      p+1=c+d&p+2=e+f
getRequestedSessionId() no      S%3F+ID
getRequestURI()         no      /app/test%3F/a%3F+b;jsessionid=S+ID
getRequestURL()         no      http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=S+ID
getScheme()                     http
getServerName()                 30thh.loc
getServerPort()                 8480
getServletPath()        yes     /test?
getParameterNames()     yes     [p 2, p 1]
getParameter("p 1")     yes     c d


=============================================================================================================================================================================================
<bean id="authenticationManager"
     class="org.springframework.security.authentication.ProviderManager">             // when to give different providers to manager
  <property name="providers">
    <list>
      <ref local="daoAuthenticationProvider"/>
      <ref local="anonymousAuthenticationProvider"/>
      <ref local="ldapAuthenticationProvider"/>
    </list>
  </property>
</bean>

Custom Filter in security==>

a)Create a class which extends GenericFilterBean

b)Override doFilter()

public class ManuCustomFilter extends GenericFilterBean {

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		// TODO Auto-generated method stub
		System.out.println("This is my Own Filter Used Before BasicAuthenticatio");


 		chain.doFilter(request, response);  /////////////////////////////////////////vvvvvvviiiiiippppppppp otherwise cshin stop here
		
	}

}

c)Register the Bean into security.xml

<beans:bean id="ManuCustomFilter" class="com.manav.ManuCustomFilter"/>

d)Now Main Points

Here are all attributes to specify exactly a place your filter in the stack:

after – describes the filter immediately after which a custom filter will be placed in the chain
before – defines the filter before which our filter should be placed in the chain
position – allows replacing a standard filter in the explicit position by a custom filter

<http>
    <custom-filter before="BASIC_AUTH_FILTER" ref="ManuCustomFilte" />
</http>





Filter-chain in Security==>

The ‹http› namespace block always creates an SecurityContextPersistenceFilter, an ExceptionTranslationFilter and a FilterSecurityInterceptor. 
These are fixed and cannot be replaced with alternatives.

And as we have set auto-config to true, BasicAuthenticationFilter, LogoutFilter and UsernamePasswordAuthenticationFilter also gets added to the filter chain

To gain finer control on the security filters that are to be applied on the request, we can define our own FilterChainProxy implementation.

<bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy">
  <sec:filter-chain-map path-type="ant">
    <sec:filter-chain pattern="/images/*" filters="none"/>
    <sec:filter-chain pattern="/**" filters="securityContextFilter, logoutFilter, formLoginFilter, servletApiFilter, anonFilter, exceptionTranslator,
    filterSecurityInterceptor, customFilter1, customeFilter2" />
  </sec:filter-chain-map>
</bean>

Filter Ordering==>
a)ChannelProcessingFilter
b)SecurityContextPersistenceFilter
c)ConcurrentSessionFilter
d)BasicAuthenticationFilter or Other Authentication
e)SecurityContextHolderAwareRequestFilter
f)RememberMeAuthenticationFilter
g)AnonymousAuthenticationFilter
h)ExceptionTranslationFilter
i)FilterSecurityInterceptor




=============================================================================================================================================================================================
Remember me in spring Security===>

a)Create a table with name persistent_logins to save tokens. So we need to specify a datasource for remember-me configuration.


create table persistent_logins (
	username varchar(64) not null, 
	series varchar(64) primary key,                                              
	token varchar(64) not null,
	last_used timestamp not null
)



b)Inside <http>
<remember-me 
        token-validity-seconds="1209600"
		remember-me-parameter="remember-me" 
		data-source-ref="dataSource" />

c)dont remember to forgot add this in Login.jsp
<tr>
			<td>Remember Me: <input type="checkbox" name="remember-me" /></td>
			</tr>

name of checkbox<==>remember-me-parametre.


Remember-me authentication is not used with basic authentication, given it is often not used with HttpSession s. Remember-me is used with UsernamePasswordAuthenticationFilter
This implementation supports the simpler approach described in Simple Hash-Based Token Approach.

Internal working==>
when we click on remember-me it will set the the username and password into the cookies and when we hit on url controller will check it is remember me or not..
if yes redirect to default-target-url else to the login page..

In JSP, you can use Spring security tag sec:authorize access="isRememberMe()" to determine if this user is login by “remember me” cookies.

Example==>

<sec:authorize access="isRememberMe()">
		<h2># This user is login by "Remember Me Cookies".</h2>
	</sec:authorize>

	<sec:authorize access="isFullyAuthenticated()">
		<h2># This user is login by username / password.</h2>
	</sec:authorize>

to check for a url in a controller whether user is rememberme() or not try this

private boolean isRememberMeAuthenticated() {

		Authentication authentication = 
                    SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return false;
		}

		return RememberMeAuthenticationToken.class.isAssignableFrom(authentication.getClass());
	}

============================================================================================================================================================================================

Session Management in Spring-Security==>

First create Logout in Spring==>

<logout logout-success-url="/login?logout"
		invalidate-session="true"
		delete-cookies="JSESSIONID"
		logout-url="/j_spring_security_logout"
		 />


<c:if test="${pageContext.request.userPrincipal.name != null}">
	<a href="<c:url value='j_spring_security_logout'/>">Logout</a>         ///It is used in jsp to check whether there is any user or not
	</c:if>


Concurrency Control==>
Spring Security is able to prevent a principal from concurrently authenticating to the same application more than a specified number of times. 
Many ISVs take advantage of this to enforce licensing, whilst network administrators like this feature because it helps prevent people from sharing login names.
You can, for example, stop user “Batman” from logging onto the web application from two different sessions. 
You can either expire their previous login or you can report an error when they try to log in again, preventing the second login. Note that if you are using the second approach, 
a user who has not explicitly logged out (but who has just closed their browser, for example) will not be able to log in again until their original session expires.

Example==>
Example==>
<http>
  <session-management>
    <concurrency-control
       max-sessions="1"\
       expired-url="/your-page-here" />                    same as invalid session-url
  </session-management>
</http>


=============================================================================================================================================================================================

Client ID, Client Secret and Redirect URI
Before a client application can request access to resources on a resource server, 
the client application must first register with the authorization server associated with the resource server.

The registration is typically a one-time task. Once registered, the registration remains valid, unless the client app registration is revoked.

At registration the client application is assigned a client ID and a client secret (password) by the authorization server. 
The client ID and secret is unique to the client application on that authorization server. 
If a client application registers with multiple authorization servers (e.g. both Facebook, Twitter and Google), 
each authorization server will issue its own unique client ID to the client application.

Whenever the client application requests access to resources stored on that same resource server, 
the client application needs to authenticate itself by sending along the client ID and the client secret to the autorhization server.

During the registration the client also registers a redirect URI. This redirect URI is used when a resource owner grants authorization to the client application. 
When a resource owner has successfully authorized the client application via the authorization server, the resource owner is redirected back to the client application, to the redirect URI.



OAuth 2.0 defines a set of endpoints. An endpoint is typically a URI on a web server. For instance, the address of a Java servlet, JSP page, PHP page, ASP.NET page etc.

The endpoints defined are:

Authorization Endpoint
Token Endpoint
Redirection Endpoint

The authorization endpoint and token endpoint are both located on the authorization server. 
The redirection endpoint is located in the client application. Each of these endpoints are covered below.


OAuth 2.0 Endpoints.
The OAuth 2.0 specification does not describe how the URI of these endpoints are found or documented. 
That is up to each implementer to decide. Most sites will have a subsite for developers documenting these endpoints.

Authorization Endpoint
The authorization endpoint is the endpoint on the authorization server where the resource owner logs in, and grants authorization to the client application.

Token Endpoint
The token endpoint is the endpoint on the authorization server where the client application exchanges the authorization code, client ID and client secret, for an access token.

Redirect Endpoint
The redirect endpoint is the endpoint in the client application where the resource owner is redirected to, after having granted authorization at the authorization endpoint.







Oauth2 Implementation==>

for every grant-type==>

**)Client credentials grant

Secured resources are under the control of client and hence client is a resource owner here.

So there is no need to obtain any authorization from the end user.

When to use this Grant type?
This should be used when client itself is a resource owner.

Example:

Client has stored some files in google cloud storage.

Client has to call the google API to access these files.

So client authenticates with the google authentication server and then obtain an access token which can be used further to access the files.


for this as we are the owner we only required acccess token==>

Note:
We will not get refresh token if the grant type is client_credentials and hence we are not getting refresh_token from OAuth.

Different types of grant types==> when to use
a)The Authorization Code grant type is used by confidential and public clients to exchange an authorization code for an access token.

After the user returns to the client via the redirect URL, the application will get the authorization code from the URL and use it to request an access token.


b)The Password credential  grant type is a simplified flow that can be used by public clients, where the access token is returned immediately without an extra authorization code exchange step.

It is generally not recommended to use the implicit flow (and some servers prohibit this flow entirely). In the time since the spec was originally written, 
the industry best practice has changed to recommend that public clients should use the authorization code flow
simply get access token by usrname and password==> only used in the industry where trust belong between clients..


c)The Client Credentials grant type is used by clients to obtain an access token outside of the context of a user.

This is typically used by clients to access resources about themselves rather than to access a user's resources....mainly in rest ...


d)Implicit grant type==>The Implicit grant type is a simplified flow that can be used by public clients, 
where the access token is returned immediately without an extra authorization code exchange step. 
It is generally not recommended to use the implicit flow 

we have implemented client credentials grant type in the session ..lets understand the code..
but Remember==>An OAuth endpoint is a URL that is exposed by Apigee Edge in your organization. 
OAuth defines token endpoints, authorization endpoints, and refresh endpoints. Apps call these endpoints to get access tokens, to refresh access tokens, 
and, in some cases, to get authorization codes. 


So first understand the flow===>

first request(Resource Owner)============>accesss token request=======>Authorization Server(with all client_id,secret,scope,grant type)

Note that the API call is sent to the /accesstoken endpoint. 
This endpoint has a policy attached to it that validates the app's credentials. 
That is, the policy compares the submitted keys with the ones that Authorization Server created when the app was registered.

(Resource Owner)<============accesss token<=======Authorization Server

(Resource Owner)============>accesss token================>Resource Server(get response)

points to remember==>

*)resource ownwer request access token on specif yrl sending all data...
*)than that request is authenticate via authorization server and all the client credentials is save on authorization--server
*)Authorization server also has its
   ******************************************************REMMBER**********************************************************************88
the Authorization Server verifies the identity of a resource owner (the user) and provides the tokens. 
Spring Security handles the Authentication part and Spring Security OAuth2 handles the Authorization part..(same as basic)



a)Client requests an access token==>dont forget to encode id and secrets in base64



<!-- This is default url provided by spring to get the tokens(access and refresh) from OAuth -->
 <http pattern="/oauth/token" create-session="stateless"
  authentication-manager-ref="clientAuthenticationManager"     // use that manager to get and save the token..
  xmlns="http://www.springframework.org/schema/security">
  <intercept-url pattern="/oauth/token" access="IS_AUTHENTICATED_FULLY" />   // not work for remember me...//this will use authorization server
  <anonymous enabled="false" />                                              // not work for anynomous user..
  <http-basic entry-point-ref="clientAuthenticationEntryPoint" />            // default entry point ref for all tokens
 
  <!-- include this only if you need to authenticate clients via request
   parameters -->
   
  <custom-filter ref="clientCredentialsTokenEndpointFilter"                  // we have learn that oauth has three endpoints remember them..only using token end point
   after="BASIC_AUTH_FILTER" />
  <access-denied-handler ref="oauthAccessDeniedHandler" />                   // default access denied handeler for oauth authentication
 </http>
 
<bean id="clientCredentialsTokenEndpointFilter"
  class="org.springframework.security.oauth2.provider.client.ClientCredentialsTokenEndpointFilter">  //as we r using token endpoint
  <property name="authenticationManager" ref="clientAuthenticationManager" />
 </bean>


<authentication-manager id="clientAuthenticationManager"
  xmlns="http://www.springframework.org/schema/security">
  <authentication-provider user-service-ref="clientDetailsUserService" />   //we r using defaul client detailUserService mostly hardcoded

 <authentication-manager alias="authenticationManager"
  xmlns="http://www.springframework.org/schema/security">
  <authentication-provider>
   <user-service id="userDetailsService">
    <user name="kb" password="kb@1234" authorities="ROLE_OAUTH_CLIENT" />
    <user name="raj" password="raj@1234" authorities="ROLE_OAUTH_CLIENT" />       ///this is done by spring security..
   </user-service>
  </authentication-provider>
 </authentication-manager>

<bean id="clientDetailsUserService"
  class="org.springframework.security.oauth2.provider.client.ClientDetailsUserDetailsService">   
  <constructor-arg ref="clientDetails" />                                   //sending client details to service..
  </bean>

<oauth:client-details-service id="clientDetails">
  <!-- client -->
  <oauth:client client-id="trusted client"
   authorized-grant-types="password,refresh_token,client_credentials"      //types of grant types..
   authorities="ROLE_OAUTH_CLIENT" scope="optional" secret="secret" />
 
  <oauth:client client-id="trusted client with secret"
   authorized-grant-types="password,authorization_code,refresh_token,implicit"
   secret="somesecret" authorities="ROLE_OAUTH_CLIENT" />
 
 </oauth:client-details-service>


This is pointing to the actual client details service which is defined as below as we know for access token we require authorization-server
As we know every first call will always go to authorization-server whatever will it be..
 
<oauth:authorization-server
  client-details-service-ref="clientDetails" token-services-ref="tokenServices"
  user-approval-handler-ref="userApprovalHandler">                                          //A default user approval handler that doesn't remember any decisions.
  <oauth:authorization-code />
  <oauth:implicit />
  <oauth:refresh-token />
  <oauth:client-credentials />
  <oauth:password />
 </oauth:authorization-server>

Here we have injected the token service to manage the refresh and access tokens.
Also defined possible Grant types in it.

<bean id="tokenServices"
  class="org.springframework.security.oauth2.provider.token.DefaultTokenServices">
  <property name="tokenStore" ref="tokenStore" />
  <property name="supportRefreshToken" value="true" />
  <property name="accessTokenValiditySeconds" value="120" />
  <property name="clientDetailsService" ref="clientDetails" />          
 </bean>


we have specified access token to be valid for 2 minutes.
We have also injected a tokenstore which will take care of storing the tokens.

we have defined tokenstore as JDBC token store as below


<bean id="tokenStore"
  class="org.springframework.security.oauth2.provider.token.store.JdbcTokenStore">
  <constructor-arg ref="jdbcTemplate" />                                    // nothing only data source-ref
  </bean>



<bean id="clientAuthenticationEntryPoint"                                  //entry point for get token
  class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint">
  <property name="realmName" value="sample/oauthClient" />                 //A realm is a credential store that enables identity or role based access control.
  <property name="typeName" value="Basic" />
 </bean>
 
<bean id="oauthAccessDeniedHandler"
  class="org.springframework.security.oauth2.provider.error.OAuth2AccessDeniedHandler" />   /// default access handeler...


==>Now We use user-approval-handler-ref="userApprovalHandler" in Authorization-server Let understand the use of this...
A default user approval handler that doesn't remember any decisions. 
means Basic interface for determining whether a given client authentication request has been approved by the current user

<!-- <bean id="requestFactory"
        class="org.springframework.security.oauth2.provider.request.DefaultOAuth2RequestFactory">
        <constructor-arg name="clientDetailsService" ref="clientDetails" />
    </bean>
 
<bean id="userApprovalHandler" class="org.springframework.security.oauth2.provider.approval.TokenStoreUserApprovalHandler">
    <property name="tokenStore" ref="tokenStore"/>
    <property name="requestFactory" ref="requestFactory" />
</bean> -->





b)now the protected url

<!-- This is where we tells spring security what URL should be protected
  and what roles have access to them -->
 
 <http pattern="/rest/api/**" create-session="never"                                        
  entry-point-ref="oauthAuthenticationEntryPoint"
  access-decision-manager-ref="accessDecisionManager"
  xmlns="http://www.springframework.org/schema/security">
  <anonymous enabled="false" />
  <intercept-url pattern="/rest/api/**" access="ROLE_OAUTH_CLIENT" />
  <custom-filter ref="resourceServerFilter" before="PRE_AUTH_FILTER" />  //resource server ref  always use pre_auth_filter 
  <access-denied-handler ref="oauthAccessDeniedHandler" />
 </http>


<oauth:resource-server id="resourceServerFilter"
  resource-id="sample" token-services-ref="tokenServices" />   //resource server uses token service as we have to send every time token to resource

 <!-- tokenServices bean for defining token based configurations, token validity etc -->
 <bean id="tokenServices"
  class="org.springframework.security.oauth2.provider.token.DefaultTokenServices">
  <property name="tokenStore" ref="tokenStore" />                                             // it uses token store
  <property name="supportRefreshToken" value="true" />
  <property name="accessTokenValiditySeconds" value="120" />
  <property name="clientDetailsService" ref="clientDetails" />              
 </bean>

 <!--We have used JDBC tokenstore to store the tokens, we can use In Memory token store for development purpose -->
 <bean id="tokenStore"
  class="org.springframework.security.oauth2.provider.token.store.JdbcTokenStore">
  <constructor-arg ref="jdbcTemplate" />
  </bean>
 
  <bean id="jdbcTemplate"
     class="org.springframework.jdbc.datasource.DriverManagerDataSource">
      <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
      <property name="url" value="jdbc:mysql://localhost:3306/manu"/>
   <property name="username" value="root"/>
   <property name="password" value="MAnv12@3"/>
  </bean>




<bean id="accessDecisionManager" class="org.springframework.security.access.vote.UnanimousBased"
  xmlns="http://www.springframework.org/schema/beans">
  <constructor-arg>
   <list>
    <bean class="org.springframework.security.oauth2.provider.vote.ScopeVoter" />     //denied access when scope is wrong
    <bean class="org.springframework.security.access.vote.RoleVoter" />               //denied access when role is wrong
    <bean class="org.springframework.security.access.vote.AuthenticatedVoter" />      //denied access when access is wrong
   </list>
  </constructor-arg>
 </bean>








http://www.techburps.com/spring-framework/spring-security-oauth2-integration/288//try also this to implement

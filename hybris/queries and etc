

As we all know that V1 OCC web services are deprecated and we use V2 OCC web services. V1 OCC web services are stateful, where V2 OCC web services are stateless.

In V1, we save some data in session. But in V2, we have to send attribute's value like customer id etc in request parameter of URL.

How V2 is better than V1?

Instead of sending information every time in URL we can save some attributes in session and use it later.

Better fault tolerance

====================================
extension generated on modulegen-->
  <extension name='trainingfulfilmentprocess' />
    <extension name='trainingcore' />
    <extension name='trainingfacades' />
    <extension name='trainingtest' />
    <extension name='trainingstorefront' />
    <extension name='traininginitialdata' />
    <extension name='trainingcockpits' />

==================================
Classes generated after build

1) Generated*.java source files for all item types of an extension to the gensrc directory of your extension.

2) *Model.java model classes for all item types of an extension to the bootstrap/gensrc directory

where * has to be replaced with item type code.

for item type SampleType1, GeneratedSampleType1.java and SampleType1Model.java files are generated once the build is done.

=====================================
<deployment table="MyContactInfo" typecode="12000"/>
Table name and typecode should be unique globally.

Typecode value should be greater than 10000 and less than 32767.

Typecode is used during the PK generation mechanism and hence it should be unique

Typecode values between 0 & 10000 are reserved by Hybris

if we don’t specify the deployment for any of our item type then deployment specified in the closest type in the hierarchy will be considered.

If there is no hierarchy which means if the item type is not extending any item type then by default GenericItem will be considered as the parent of the item type.
And hence the deployment of GenericItem will be used by the item type.

So all the instances of this item type will be stored in the GenericItem table


When we should define deployment mandatorily?

We should define deployment for an item type in the following scenarios

1) Defining new item type by extending GenericItem
Example:

<itemtype code="Unit"
                  extends="GenericItem"
                  jaloclass="de.hybris.platform.jalo.product.Unit"
                  autocreate="true"
                  generate="true">
            <deployment table="Units" typecode="10"/>
2)Defining new item type by extending existing item type for which there is no deployment
Example:


<itemtype code="AbstractOrder"
                  extends="GenericItem"
                  jaloclass="de.hybris.platform.jalo.order.AbstractOrder"
                  autocreate="true"
                  generate="true"
                  abstract="true">
<itemtype code="Cart"
                  extends="AbstractOrder"
                  jaloclass="de.hybris.platform.jalo.order.Cart"
                  autocreate="true"
                  generate="true">
            <deployment table="Carts" typecode="43"/>
deployment is not defined for AbstractOrder as its abstract type,Cart is extending AbstractOrder , so deployment must be defined for Cart.

========================================================================================================================================
Collection-->

<collectiontype code="StringCollection" elementtype="java.lang.String" autocreate="true" generate="false" type=list/>

autocreate will be true as it will create a table in db.


we will use it in itemtype-->
<attribute qualifier="languages" type="LanguageList">//addresses ootb
                        <modifiers unique="false" read="false"/>
                        <persistence type="property" />
                    </attribute>
					
How collection will be stored in DB ?

There are 2 cases in Collection

1)Collection of Atomic type
In our CustomUser item type we have defined List of nickName Where nickName is a String which is atomic type.

If collection contains atomic types then the values are stored as binary fields in the database.

2)Collection of Non atomic/composed type
In our CustomUser item type we have defined List of Language Where Language is a separate item type.

If collection contains complex types then those items PKs are stored as one single String separated by comma for each PK in the database.


but collection will have a different table in db..with its name.but we cannot insert the data in that collection through backoffice. but can through impex.

--------
Enum-->
<enumtype code="Gender" autocreate="true" generate="true">ootb
            <value code="MALE"/>
            <value code="FEMALE"/>
</enumtype>

it will create a different table with name and put value into this.

If we add any non-dynamic Enum type without values,build will fail as it does not have any effect.

So if you want to add new values at run time we have to make dynamic=”true” for an Enum type.

We can change the flag anytime but enforces a system update.

dynamic enum --->orderStatus. here impex will work.



---------------------------------------
map-->Map Type
We know that Map is a collection of Key value pair.

Key is also called argument and value is also called return value.

<maptype code="addressMap"
                 argumenttype="java.lang.String"
                 returntype="Address"
                 autocreate="true"
                 generate="false"/>
				 
				 
using it -->

<attribute qualifier="userAddressMap" type="addressMap">
                        <modifiers unique="false" read="false"/>
                        <persistence type="property" />
                    </attribute>
					
its db is same as collection...


inserting map type in impex-->

INSERT XYZ;mapAttriubute(key(uid),value)[map-delimiter=|][key2value-delimiter=->]




-----------------
Relation-->
<relation code="User2ContactInfos" generate="true" localized="false" autocreate="true">
            <sourceElement type="User" cardinality="one" qualifier="user">
                <modifiers read="true" write="true" search="true" optional="false"/>
            </sourceElement>
            <targetElement type="AbstractContactInfo" cardinality="many" qualifier="contactInfos" ordered="true">
                <modifiers read="true" write="true" search="true" optional="true" partof="true"/>
            </targetElement>
        </relation>
		
		it will create a different table with saving foreign key...
		
		it is better than collection because it is bidirectional and we can store big data it will not be truncated but slow in fetching due to joins.

<relation code="CategoryProductRelation" autocreate="true" generate="true" localized="false">
            <deployment table="Cat2ProdRel" typecode="143"/>
            <sourceElement qualifier="supercategories" type="Category" cardinality="many" ordered="false">
                <description>Super Categories</description>
                <modifiers read="true" write="true" search="true" optional="true"/>
            </sourceElement>
            <targetElement qualifier="products" type="Product" cardinality="many" collectiontype="list" ordered="true">
                <description>Products</description>
                <modifiers read="true" write="true" search="true" optional="true"/>
            </targetElement>       
        </relation>



One table will be created for Products
One table will be created for Categories
One extra table will be created for LinkItem(elements on both sides of the relation are linked together via instances of a LinkItem table)

Each LinkItem instance stores the PKs of the related items for each row.

So every row of product with associated category will have one row in the LinkItem table with PK of Catrgory and associated PK of Product.

LinkItem instances are used internally by hybris.
We just need to call getters and setters at the API level to set and get the values.

Note:
Extra table will be created only for many to many relations
dur to bidirectional mapping it is preferred over collection.

In one to many --->extra column will create in which cardanality is many....which is the foreign key of main entity....

<relation code="Country2RegionRelation" generate="true" localized="false" autocreate="true">
            <sourceElement type="Country" qualifier="country" cardinality="one">
                    <modifiers read="true" write="true" search="true" optional="false" unique="true"/>
            </sourceElement>
            <targetElement type="Region" qualifier="regions" cardinality="many">
                    <modifiers read="true" write="true" search="true" partof="true"/>
            </targetElement>
</relation>

since there is a relation between 2 tables,The primary key of Country table will become the foreign key in Region table and looks like below

impex of one to many --->
INSERT_UPDATE Country;isocode[unique=true]
;US


INSERT_UPDATE Region;country(isocode);isocode[unique=true]
;US;US-AL
;US;US-AK
;US;US-AZ
;US;US-AR
;US;US-CA

----------------------------------------
For every dynamic attribute we define, we need to mention the attribute handler otherwise Bean Id will be generated automatically and we have to use the same bean id while defining Spring bean in XML.

When we should go for Dynamic attribute?

We should choose dynamic attribute whenever we want to get some derived data based on existing values.

So instead of saving one more column, we can make it as dynamic and compute its value based on the current values.

so we dont need setter here.

But setting autocreate to ‘true’, the attribute descriptor will be created used internally by hybris not column in the table on attribute level.

we have to override its 
  @Override
      public Integer get(final CustomerModel model)

=================================
Redeclare-->

<itemtype code="Country" extends="C2LItem" jaloclass="de.hybris.platform.jalo.c2l.Country"
                  autocreate="true" generate="true">
            <deployment table="Countries" typecode="34"/>
       <attributes>
               <attribute qualifier="isocode" type="java.lang.String"
                           redeclare="true" generate="false">
               <modifiers read="true" write="true" search="true" optional="false" unique="true"/>
                </attribute>
        </attributes>
</itemtype>


Sometimes it is required to re declare the attribute in the child item type for various reasons.

It could be to change the Data type of an attribute or make an attribute as read only etc.

So We can re declare the same attributes in the Child item type to change such behavior

Examples:
We can change the modifier from read=true to read=false

We can make attribute as unique.

We can add write=false.

We can also change the type of the attribute but only to subtypes.
===================================================================================================================================================
impex-->

inserting collection values using delimitter-->

collection-delimiter
The collection delimiter can be used to change the default delimiter. By default this is a colon: ,.

1
2
INSERT_UPDATE User ; Name ; groups(uid)[collection-delimiter=/] ;
; Seblink ; customergroup/customerservicegroup/admingroup ;

to add values in collection -->

INSERT_UPDATE User ; name ; groups(uid)[mode=append] ;
; Seblink ; admingroup ;

-----------------


===================================================================================================================================================
Scripting job ===>

a)create script first through backoffice.
b)create scripting job with refrence model://removePromoApplicationScript(script refrence)
c)than go to cronjob---create new and add it and its trigger.

==================================================================================================================================
inner query-->


checking shipped code is null or not  =>

select {o.code} from {AmwayEventStagingEntry as e join Order as o on {o.code} like  CONCAT(SUBSTR({e.key}, 1, 9), '%') JOIN EventName as en on {e.eventName} = {en.pk}}where {e.eventName} IN ('8796131033179') and {o.date} >'2020-02-01 00:01:00' and {o.pk} IN ({{SELECT {o:PK} FROM{
    Order as o JOIN IndShipmentOrderRel as rel
    ON {o:PK} = {rel:target}
    JOIN Consignment AS c
    ON {rel:source} = {c:PK}} where {c:CODE} IS NULL}})


----------------------------------------------------------------------------------------------------------------------------------
payment transactions will be multiple if you do partial payment.

//report query
fetching all paymentTransaction entry from paymentTransaction whose order is not null and which are placed by web and pos on dates.
salesApplication has many orders.
order can have many transactions
transaction can have many transaction entries(useful for time{transaction})

SELECT {pte.PK} FROM {PaymentTransactionEntry as pte   left join PaymentTransaction as pt on {pte.paymentTransaction} = {pt.pk}   left join Order as o on {o.pk}={pt.order}    left join SalesApplication as sa on {sa.pk}={o.salesApplication}} WHERE {pt.order} IS NOT NULL  AND  {sa.code} in ('Web', 'pos') AND  {pte.time} > '2020-01-28 00:01:00' AND  {pte.time} < '2020-01-28 23:59:59'

------------------------------------------------------------------------------------------------------------------------------------------
///bank transfer query
fetching all payment transaction entry which has transaction mode 'BANK_TRANSFER' and PaymentTransactionType 'REFUND_STANDALONE' and 
transactionStatus IN 'REFUND_REQUESTED'.

every paymentTransaction has transaction mode(enum),paymentTransaction can have many transaction entries.
transaction entries has PaymentTransactionType and transaction status.

SELECT {pte.PK} FROM {PaymentTransactionEntry as pte JOIN PaymentTransactionType as ptt ON {pte.type} = {ptt.pk}} WHERE  {ptt.code}='REFUND_STANDALONE' AND {pte.transactionStatus} IN ('REFUND_REQUESTED') AND {pte.paymentTransaction} IN ({{ SELECT {paytrn.pk} FROM {PaymentTransaction as paytrn JOIN INDTransactionModeEnum as tme ON {paytrn.transactionMode} = {tme.pk}} WHERE {tme.code}='BANK_TRANSFER'}})AND  {pte.time} > '2020-01-28 00:01:00' AND  {pte.time} < '2020-01-29 00:01:00'


using sub query=>
SELECT count({pte.transactionStatus}) FROM {PaymentTransactionEntry as pte JOIN PaymentTransactionType as ptt ON {pte.type} = {ptt.pk}} WHERE {pte.paymentTransaction} IN ({{ SELECT {paytrn.pk} FROM {PaymentTransaction as paytrn JOIN INDTransactionModeEnum as tme ON {paytrn.transactionMode} = {tme.pk}} WHERE {tme.code}='BANK_TRANSFER'}})AND  {pte.time} > '2020-01-27 00:01:00' AND  {pte.time} < '2020-01-29 00:01:00'

------------------------------------------------------------------------------------
order   has payinfo /paymentmode/paymentstatus
and transaction  has payinfo /paymentmode.


paymentmode is model and transaction mode is enum.


--------------------------------------------------------------------------------------------------------------------------------------

String[] stringArray = new String[] { "A", "B", "C", "D" };
List stringList = Arrays.asList(stringArray);
Now, let's see what happens if we modify the first element of stringList:

stringList.set(0, "E");
 
assertThat(stringList).containsExactly("E", "B", "C", "D");
assertThat(stringArray).containsExactly("E", "B", "C", "D");
As we can see, our original array was modified, too. Both the list and the array now contain exactly the same elements in the same order.

Let's now try to insert a new element to stringList:

stringList.add("F");
java.lang.UnsupportedOperationException
	at java.base/java.util.AbstractList.add(AbstractList.java:153)
	at java.base/java.util.AbstractList.add(AbstractList.java:111)
=================================================================================================================================================


=======================================================================================================================================================

<modifiers read="true" write="true" search="true"
                            initial="true" optional="true" unique="false" />
							
							initial use mtlb kuch final values de do model creation me jo baad me change ni ho ske
setter se jb  bad me change krne jaega to ni krne dega

initial = "true" means that you definitely need to fill out this attribute when creating the model. Otherwise, you cannot save the model.

It’s very important to do so for the attributes that can be used as indexes in the database, such as product code, UID, etc.

=========================================
How to export impex in csv

INSERT_UPDATE B2BCustomer;uid[unique=true]   ///whatever fields we write here they will export
"#% impex.exportItemsFlexibleSearch(""select {c.pk} from {B2BCustomer as c} where {c.dist_Type}='D' and {c.encodedPassword}='' and {c.active}=true"");"

INSERT_UPDATE Order;code[unique=true];creationtime;totalPrice;deliveryCost;
"#% impex.exportItemsFlexibleSearch(""select {od.pk} from {order as od join deliverymode as dm on {od.deliverymode}={dm.pk} join ZoneDeliveryModeValue as zdm on {zdm.pk}={od.ZoneDeliveryModeValue} join zone as zn on {zdm.zone}={zn.pk} } where {dm.deliverytype}='8796154855515' and {od.lynxgrandtotalprice}>'4000' and {od.creationtime} >='2020-02-01' and {od.deliverycost}!='0E-8' and {zn.code}='Local'"");"


REMEMBER===>Always select pk in query

https://stackoverflow.com/questions/45508160/exporting-collection-types-using-impex-in-hybris
=======================================================================================================================================================

==================================================================================================================

to find  customer having multiple cart===>

SELECT ({c.pk}) FROM {Cart as c join CartEntry as ce on {c.pk}={ce.order} join Customer as cu on {c.user}={cu.pk}}  where {cu.uid}!='anonymous' group by ({c.pk}) having COUNT(*)>1


	
==========================================================================================================================
IOUtils.closeQuietly(inputStream);/////to close streams in finally block,inputstream mainly use to read data.
=========================================================================================================================

to select multiple classes in query search==>

activeOrderSearchQuery.setResultClassList(Arrays.asList(WarehouseModel.class, OrderModel.class));
		final SearchResult<List<Object>> searchResult = flexibleSearchService.search(activeOrderSearchQuery);
		
============================================================================================================================

/psdtocache/project.properties===>we use to cache populator

============================================================================================================================

Here we convert cart into Order using this method==>

getCheckoutFacade().placeOrderWithoutConversion();

which call internally==>createCartFRomOrder(CartModel);
==============================================================================================================================
in.getNumber().stream().filter(s->inf.getNumber().contains(s)).forEach(System.out::println); ///fetching common elements from lists.
==============================================================================================================================

FlexibleSearch is able of retrieving raw data as well as items. Furthermore, it is possible to select multiple attributes or columns. The result of multi-attribute selections is a list of lists.

 String query = "SELECT {" + UnitModel.PK + "}, LOWER({" + UnitModel.CODE + "}), {" + UnitModel.NAME + "} FROM {"
                + UnitModel._TYPECODE + "}";
 final FlexibleSearchQuery fQuery = new FlexibleSearchQuery(query);
 fQuery.setResultClassList(Arrays.asList(UnitModel.class, String.class, String.class));
 final SearchResult<List<?>> result = flexibleSearchService.search(fQuery);
 final List<List<?>> resultList = result.getResult();
 
 for (final List<?> list : result)
 {
        final UnitModel unit = (UnitModel) list.get(0);
        final String code = (String) list.get(1);
        final String name = (String) list.get(2);
 
        // ....
 }
=============================================================================================================================
SiteMapController==>MIscRobotsPage.jsp/////we use them for google bot in hybris.

https://help.sap.com/viewer/4c33bf189ab9409e84e589295c36d96e/1811/en-US/8adb25b386691014af16eb036124f349.html
=============================================================================================================================
Instant start = Instant.now();     //current time
Duration timeElapsed = Duration.between(start, end);   //to check difference

The toinstant() method is used to convert Date object to an Instant.

Duration – Measures time in seconds and nanoseconds.
Period – Measures time in years, months and days.

// Creating Durations
        System.out.println("--- Examples --- ");

        Duration oneHours = Duration.ofHours(1);
        System.out.println(oneHours.getSeconds() + " seconds");

        Duration oneHours2 = Duration.of(1, ChronoUnit.HOURS);
        System.out.println(oneHours2.getSeconds() + " seconds");

		// Test Duration.between
        System.out.println("\n--- Duration.between --- ");

        LocalDateTime oldDate = LocalDateTime.of(2016, Month.AUGUST, 31, 10, 20, 55);
        LocalDateTime newDate = LocalDateTime.of(2016, Month.NOVEMBER, 9, 10, 21, 56);

        System.out.println(oldDate);
        System.out.println(newDate);

        //count seconds between dates
        Duration duration = Duration.between(oldDate, newDate);

        System.out.println(duration.getSeconds() + " seconds");

    }
}
Output

--- Examples ---
3600 seconds
3600 seconds

--- Duration.between ---
2016-08-31T10:20:55
2016-11-09T10:21:56
6048061 seconds





Period Example--->

 System.out.println("--- Examples --- ");

        Period tenDays = Period.ofDays(10);
        System.out.println(tenDays.getDays()); //10

        Period oneYearTwoMonthsThreeDays = Period.of(1, 2, 3);
        System.out.println(oneYearTwoMonthsThreeDays.getYears());   //1
        System.out.println(oneYearTwoMonthsThreeDays.getMonths());  //2
        System.out.println(oneYearTwoMonthsThreeDays.getDays());    //3

        System.out.println("\n--- Period.between --- ");
        LocalDate oldDate = LocalDate.of(1982, Month.AUGUST, 31);
        LocalDate newDate = LocalDate.of(2016, Month.NOVEMBER, 9);

        System.out.println(oldDate);
        System.out.println(newDate);

        // check period between dates
        Period period = Period.between(oldDate, newDate);

        System.out.print(period.getYears() + " years,");
        System.out.print(period.getMonths() + " months,");
        System.out.print(period.getDays() + " days");

    }
}
Output

--- Examples ---
10
1
2
3

--- Period.between ---
1982-08-31
2016-11-09
34 years,2 months,9 days



3. ChronoUnit Example
Alternatively, you can use ChronoUnit.{unit}.between to find out the difference between dates, review the following example :

ChronoUnitExample.java
package com.mkyong.time;

import java.time.LocalDateTime;
import java.time.Month;
import java.time.temporal.ChronoUnit;

public class ChronoUnitExample {

    public static void main(String[] args) {

        LocalDateTime oldDate = LocalDateTime.of(1982, Month.AUGUST, 31, 10, 20, 55);
        LocalDateTime newDate = LocalDateTime.of(2016, Month.NOVEMBER, 9, 10, 21, 56);

        System.out.println(oldDate);
        System.out.println(newDate);

        // count between dates
        long years = ChronoUnit.YEARS.between(oldDate, newDate);
        long months = ChronoUnit.MONTHS.between(oldDate, newDate);
        long weeks = ChronoUnit.WEEKS.between(oldDate, newDate);
        long days = ChronoUnit.DAYS.between(oldDate, newDate);
        long hours = ChronoUnit.HOURS.between(oldDate, newDate);
        long minutes = ChronoUnit.MINUTES.between(oldDate, newDate);
        long seconds = ChronoUnit.SECONDS.between(oldDate, newDate);
        long milis = ChronoUnit.MILLIS.between(oldDate, newDate);
        long nano = ChronoUnit.NANOS.between(oldDate, newDate);

        System.out.println("\n--- Total --- ");
        System.out.println(years + " years");
        System.out.println(months + " months");
        System.out.println(weeks + " weeks");
        System.out.println(days + " days");
        System.out.println(hours + " hours");
        System.out.println(minutes + " minutes");
        System.out.println(seconds + " seconds");
        System.out.println(milis + " milis");
        System.out.println(nano + " nano");

    }
}
Output

1982-08-31T10:20:55
2016-11-09T10:21:56

--- Total ---
34 years
410 months
1784 weeks
12489 days
299736 hours
17984161 minutes
1079049661 seconds
1079049661000 milis
1079049661000000000 nano
=============================================================================================================================
Points to remember for wrirting a util class...

class should be final..
methods should be static.

------------------------------------------------------
singleton-->
Remember the key points while defining a class as a singleton class that is while designing a singleton class:

Make a constructor private.
Write a static method that has the return type object of this singleton class. Here, the concept of Lazy initialization is used to write this static method.

==============================================================================================================================
use Objects.nonNull(warehouse)==>to check object is null or not..

CollectionUtils.emptyIfNull(Collection<T> collection)   ///use to return empty collection if null..

Localization.getLocalizedString()///used for error display in localized.


Popular methods of CollectionUtils===>
 have two sets, A and B, of the same type.

I have to find if A contains any element from the set B.

1==>Collections.disjoint(A, B) work? From the documentation:

Returns true if the two specified collections have no elements in common.

Thus, the method returns false if the collections contains any common elements.


2==>setA.stream().anyMatch(setB::contains)


3==>CollectionUtils.containsAny(someCollection1, someCollection2)
That is All! Returns true if at least one element is in both collections.
Simple to use, and the name of the function is more suggestive.


 // replace oldValue with square of oldValue 
        // using replaceAll method 
        map1.replaceAll((key, oldValue) 
                            -> oldValue * oldValue); 


	
Set<Map.Entry<String, Integer>> entries = someMap.entrySet(); ///fetching entryset

Map.entrySet().stream()
					.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); ///new collection
					

list.removeIf(string -> string.endsWith("suffix"));

list.stream().limit(1);   //for first element


Another Example==>
paymentModesToPass.removeIf(paymentModeData -> codes.contains(paymentModeData.getCode())); //here paymentModeData check for every ele in lost.
 method in lIST.

---------------------------------------------------------------------
List<Integer> list1 = new ArrayList<>(Arrays.asList(1,5,10,30,4,8,11));
List<Integer> list2 = new ArrayList<>(Arrays.asList(1,5,10,30,4,8,11));

/* Retains all elements in list that have a value > 5 */
CollectionUtil.retainIf(list1, element -> element > 5);

System.out.println("List 1");
list1.forEach(System.out::println);

/* Removes all elements in list that have a value > 5 */
CollectionUtil.removeIf(list2, element -> element > 5);

System.out.println("\nList 2");
list2.forEach(System.out::println);
Output

List 1
10
30
8
11

List 2
1
5
4

-------------------------

public void testExists() {
  List list = new ArrayList();
  assertEquals(false, CollectionUtils.exists(null, null));
  assertEquals(false, CollectionUtils.exists(list, null));
  assertEquals(false, CollectionUtils.exists(null, EQUALS_TWO));
  assertEquals(false, CollectionUtils.exists(list, EQUALS_TWO));
  list.add("One");
  list.add("Three");
  list.add("Four");
  assertEquals(false, CollectionUtils.exists(list, EQUALS_TWO));
  list.add("Two");
  assertEquals(true, CollectionUtils.exists(list, EQUALS_TWO));
}

Answers true if a predicate is true for at least one element of a collection.
A null collection or predicate returns false.


--------------------------------------------

We can use CollectionUtils's addIgnoreNull method to add only non-null elements to a provided collection.

boolean isNotEmpty = (list != null && list.size() > 0); /////for atleast one Element.

-----------------------------------------------
groupingBy()==>The groupingBy() method of Collectors class in Java are used for grouping objects by some property and storing results in a Map instance. In order to use it, we always need to specify a property by which the grouping would be performed. This method provides similar functionality to SQL’s GROUP BY clause.


 // Get the List 
        List<String> g 
            = Arrays.asList("geeks", "for", "geeks"); 
  
        // Collect the list as map 
        // by groupingBy() method 
        Map<String, Long> result 
            = g.stream().collect( 
                Collectors.groupingBy( 
                    Function.identity(), 
                    Collectors.counting())); 
  
        // Print the result 
        System.out.println(result); 
		
out--->{geeks=2, for=1}

-----------------------------------------------------
 Function<Integer, Integer> identityFunction = Function.identity();
    Function<Integer, Integer> intFunction = e -> e;                                      //defining interface
    
    System.out.println(identityFunction.apply(10)); // 10 
    System.out.println(intFunction.apply(10)); // 10

 List<String> names = Arrays.asList(
         "Peter",
         "Martin",
         "John",
         "Vijay",
         "Arthur"
        );
    
    // Just for example
    System.out.println("----- Function.identity() -----");
    names.stream().map(Function.identity()).forEach(System.out::println);
    
    System.out.println("----- Function(e-> e) -----");
    names.stream().map(e->e).forEach(System.out::println);
  }
}
Output :

10
10
----- Function.identity() -----
Peter
Martin
John
Vijay
Arthur
----- Function(e-> e) -----
Peter
Martin
John
Vijay
Arthur


>>>>>>>>>>Function.identity()==e->e ////true
========================================================================================================================
Speed up hybris server start

1)	Extract “hawkeye.rar” using 7 Zip in your local machine. Like in C drive.
2)	Update your hybris setup “local.properties” file  by adding/updating below properties:-
(i)		installed.tenants=
(ii)	task.engine.loadonstartup=false
(iii)	cronjob.timertask.loadonstartup=false
(iv)	tomcat.debugjavaoptions=-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n -Dfile.encoding=UTF8 -javaagent:"C://hawkeye//hawkeye.jar"
3)	Run ant clean all.
4)	Run hybrisserver.bat.

=============================================================================================================================

==============================================================================================================================

for occ==> commercewebservices.rootcontext=/myws/v1/     for urls

ant addoninstall -Daddonnames="occaddon" -DaddonStorefront.ycommercewebservices="mycommercewebservices  //installing occ addon 

Populating data from the commerce layer to web services DTO is done with the help of Orika - a popular Java Bean mapper framework
 
 

As you already mentioned, you could change the dto-level-mappings-v2-spring.xml so that for all levels (BASIC, DEFAULT, FULL) only the uid is returned.

///this is for what values we have to map only


<bean parent="fieldSetLevelMapping" id="b2bunitWsDTOFieldSetLevelMapping">
    <property name="dtoClass"
              value="de.hybris.platform.b2boccaddon.dto.pricerow.B2bUnitWsDTO"/>
    <property name="levelMapping">
        <map>
            <entry key="BASIC" value="PointOfServiceData(uid)" />
            <entry key="DEFAULT" value="PointOfServiceData(uid)" />
            <entry key="FULL" value="PointOfServiceData(uid)" />
        </map>
    </property>
</bean>
Beware, the fieldSetLevelMapping beans only define how your response looks like!   ////*****


 ==>in this we declare what value is mapp to what value of wsdto..
  
  <bean id="b2bUnitFieldMapper" parent="fieldMapper">
    <property name="sourceClass"
              value="de.hybris.platform.b2bcommercefacades.company.data.B2BUnitData"/>
    <property name="destClass"
              value="com.customer.some.package.B2bUnitWsDTO"/>
    <property name="fieldMapping">
        <map>
            <entry key="PointOfServiceData.uid" value="pointOfServiceUID"/>
        </map>
    </property>
</bean>

  V2 is the default version after hybris 5.4.
● Calls in V2 are stateless whereas in V1 calls are stateful.


What are the filters a new V2 request passes through.?
1. Session Filter
2. Site Matching Filter
3. Spring security filter chain
4. User matching Filter
5. Cart matching Filter


=================================================================================================================================
We did following approach for alternate data source, this should work here.

Step 1:  Configure master and alternate datasources in local.properties file.
db.url=jdbc:mysql://<hostname>/<dbname>?useConfigs=maxPerformance&characterEncoding=utf8
db.driver=com.mysql.jdbc.Driver
db.username=<username>
db.password=<password>
 
alt.datasource.alt1.active=true
alt.datasource.alt1.db.url=jdbc:mysql://<hostname>/<dbname>?useConfigs=maxPerformance&characterEncoding=utf8
alt.datasource.alt1.db.driver=com.mysql.jdbc.Driver
alt.datasource.alt1.db.username=<username>
alt.datasource.alt1.db.password=<password>

Step 2: Create custom code to query alternate data base
        final Tenant tenant = Registry.getCurrentTenantNoFallback();
        ((AbstractTenant) tenant).cancelForceMasterMode();// don’t remember if this is needed
        tenant.activateAlternativeMasterDataSource("alt1");
      // DB call in the code here
        tenant.deactivateAlternativeDataSource();
        return result;
    }
 
    
===================================================================================================================
hybris can be run in a Multi-Tenant mode which multiple individual sets of data are maintained on one single hybris installation. When a bean is defined with a tenant scope, it will only be instantiated individually for each tenant; whereas singleton would create only one instance for all tenants to use.

===================================================================================================================
 </attributes>                
                <indexes>
                    <index name="lynxTnaUserProductIDX" unique="true">          //for faster result while fetching in where from coloumn
                        <key attribute="user"/>
                        <key attribute="product"/>
                    </index>
                </indexes>        

========================================================================================================================
 //Converting the Object to JSONString
      String jsonString = mapper.writeValueAsString(eventData.getEventPayload());   ////object mapper
	   
println StringEscapeUtils.unescapeJava(jsonString);                            ///not to remove null objects


========================================================================================================
select * from sys.indexes where name like 'index_name'

//to see index in hsql

======================================================================================================================================
Same site cookie-->

ist party cookie-->created by domain
3rd party cookie-->created by advertisement

sometimes when we login in bank accounts or any accounts like gmail...jssesion id saves in cookie...and if any advertisement or link
we click which redirect to these sites cookies will also sent....which is use for csrf...

to control this chrome introduce new property in cookies sameSite...

1)sameSite=strict--->if we use it cookie will only be send if you are on same site or domain.....not by any link or url from 3rd party.and also not allow any 3rd party to fetch any data from your site.

2)sameSite=lax ----->it will not allow to fetch 3rd party any data from your site...but will sent cookie if u r redirected to your site by any link or url.

3)sameSite=none----->no security...will always send cookie from everywhere.


=========================================================================================================================================
When using singleton-scoped beans that have dependencies on beans that are scoped as prototypes, please be aware that dependencies are resolved at instantiation time. This means that if you dependency inject a prototype-scoped bean into a singleton-scoped bean, a brand new prototype bean will be instantiated and then dependency injected into the singleton bean... but that is all. That exact same prototype instance will be the sole instance that is ever supplied to the singleton-scoped bean, which is fine if that is what you want.

However, sometimes what you actually want is for the singleton-scoped bean to be able to acquire a brand new instance of the prototype-scoped bean again and again and again at runtime. In that case it is no use just dependency injecting a prototype-scoped bean into your singleton bean, because as explained above, that only happens once when the Spring container is instantiating the singleton bean and resolving and injecting its dependencies. If you are in the scenario where you need to get a brand new instance of a (prototype) bean again and again and again at runtime, you are referred to the section entitled Section 4.3.7, “Method Injection”

Soln==>

public class MySingletonBean {

    @Autowired
    private ApplicationContext applicationContext;

    public void showMessage(){
        MyPrototypeBean bean = applicationContext.getBean(MyPrototypeBean.class);
        System.out.println("Hi, the time is "+bean.getDateTime());        //use this
    }
}
=========================================================================================================================================
I ran into this issue on a Macbook Pro running Hybris 6.5.0.2, Java 1.8.0_151, and JRebel 7.1.2. Given that it seems intermittent (based on earlier comments), it's difficult to prove that this is really "fixed", but I got around it by increasing the stack size to 512k, up from 256k: -Xss512K. This is set in the tomcat.generaloptions property.
=========================================================================================================================================
<itemtype code="AmwayProductSerialNumber" generate="true"
autocreate="false">
<description>Serial number for order entry</description>
<attributes>
<attribute qualifier="serialType" type="IndSerialTypeEnum">
<description>Serial type</description>
<modifiers read="true" write="true" search="true"
optional="false" />
<defaultvalue>em().getEnumerationValue("IndSerialTypeEnum", "ROC")</defaultvalue>  ///way to put enumeration values
<persistence type="property" />
</attribute>
</attributes>
<indexes>
<index name="AmwayProductSerialNumberIDX" >
<key attribute="serialNumber" />
<key attribute="consignmentEntry" />
<key attribute="serialType" />
</index>
</indexes>
</itemtype>


===========================================================================================================================================
recurrencyLevel - define how many recurrency level builder should support (it is case when object have it's own type field e.g. VariantMatrixElementData have elements which are also VariantMatrixElementData type)



<bean id="defaultFieldSetBuilder"
      class="de.hybris.platform.webservicescommons.mapping.impl.DefaultFieldSetBuilder">
   <property name="defaultRecurrencyLevel" value="4"/>
   <property name="defaultMaxFieldSetSize" value="50000"/>
   <property name="fieldSetLevelHelper" ref="fieldSetLevelHelper"/>
</bean>


========================================================================================================================================
<model>
                        <getter default="true" name="calculated">
                            <nullDecorator>Boolean.valueOf(false)</nullDecorator>
                        </getter>
                    </model>
					
					itm.xml-->
					
				wo bas isliye ki aapka value null ni aaye.. default value works only for new instances
				anytime if we fetch the value will not be null..if someone removes it...u still get default value.
				
===========================================================================================================================================
Because there is relation between paymentTransaction and paymentTransactionEntry, also paymentTransaction and Order

modelService.saveAll(paymentTransactionEntry) se teeno save ho jaane chahiye


=============================================================================================================================================
Once you execute the following command :

ant addoninstall -Daddonnames="myAddOn" -DaddonStorefront.yacceleratorstorefront="myStorefront"
ant addoninstall will :

Add myAddOn into extensioninfo.xml as required for myStorefront extension
Add myAddOn to addons.less for myStorefront
Generate a new project.properties file from the project.properties.template inside myAddOn.
Configure the myAddOn web spring configuration myAddOn-web-spring.xml into myStorefront.additionalWebSpringConfigs
When need to uninstall an addon, does it need to use the uninstall command?

Yes, you need to execute ant addonuninstall in order to rollback the actions listed in the second response.



===========================================================================

Make custom extension as Extension Template

We can make our custom extension also as extension template so that it appears in the list of extension templates during ant extgen command

To achieve this , we need to define the below tag in extensioninfo.xml


meta key="extgen-template-extension" value="true"

Adding this enables our extension to appear in the ant extgen command templates list.

we have also need to create a extra propertiesfile...

extgen.properties and need to add properties-->

YEXTNAME_TOKEN=ysapordermgmtb2baddon             
 YPACKAGE_TOKEN=de.hybris.platform.sap.ysapordermgmtb2baddon
 YMANAGER_TOKEN=Ysapordermgmtb2baddonManager
 YCLASSPREFIX_TOKEN=Ysapordermgmtb2baddon
	 
============================================================================================================



===============================================================
Items.xml file is evaluated in one pass unlike impex which is multi pass processed.

Because of single pass,we need to specify the item types in the order of inheritance.
 
More abstract types has to be defined at the beginning of the items.xml file
More concrete types has to be defined at the end of the items.xml file


 
If we reverse the above item type definition as below, build will fail.



========================================================================================

autocreate=true at the item type level
It hints hybris to create a new database entry for this type at initialization/update process
If we set it to false,build will fail.
We should set it to true for the first definition of item type.


generate=true at the item type level
It hints hybris to generate a new jalo class for this type during build time.
If we set it to false,then jalo class will not be generated however model class will always be generated.
We should set it to true for the first definition of item type.



================================================================================================
1) If we don’t specify deployment for the above scenarios then build will fail.
If we want to pass the build and let items to be stored in GenericItem table then define below property in the local.properties file


build.development.mode=false
This is not advisable because storing many item types in GenericItem table will decrease the performance and possibility of data truncation due to columns limit in the table.

==================================================================================================

All map are save in MapType in hybris

====================================================================================================

There are 5 main interceptors provided by Hybris

1) Init Defaults interceptor    //create
2) Prepare interceptor          //This is called before a model is saved to the database and before it is validated by Validate interceptors.
                                We can use this to add values to the model or modify existing ones before they are saved. 
3) Validate interceptor         //This is called before a model is saved to the database after is been prepared by the Prepare interceptors.
4) Load interceptor             //This is called when we retrieve the model from the database.
                                We can use load interceptor if we want to change the values of the model after loading it. 
5) Remove interceptor


Requirement :
Save consignment carrier code to Consignment model while saving it.
Carrier code is available in CarrierModel

public class ConsignmentPrepareInterceptor implements PrepareInterceptor<ConsignmentModel>
{
 
    @Override
    public void onPrepare(ConsignmentModel consignment, InterceptorContext ctx) throws InterceptorException
    {
        final CarrierModel carrier = consignment.getCarrierDetails();
        final String carrierCode = carrier == null ? null : carrier.getCode();
        consignment.setCarrier(carrierCode);
    }
 
}


<bean id="consignmentPrepareInterceptor" class="de.hybris.platform.consignmenttrackingservices.interceptor.ConsignmentPrepareInterceptor"/>

Step 3
Map this interceptor with corresponding model


<!-- Mapping Interceptor and model class-->
<bean id="consignmentPrepareInterceptorMapping" class="de.hybris.platform.servicelayer.interceptor.impl.InterceptorMapping">
        <property name="interceptor" ref="consignmentPrepareInterceptor"/>
        <property name="typeCode" value="Consignment"/>
    </bean>
===================================
	
	TaskEngine: For every trigger there is always one Task item gets created in Hybris.

TaskEngine will keep on polling the Tasks for every X seconds which we configure in the local.properties file as below


cronjob.trigger.interval=30



We can also run the cron job using Ant command as below

ant runcronjob -Dcronjob=myCronJob -Dtenant=master


The core-spring. xml file of the core extension adds a special scope named tenant to the global ApplicationContext. The tenant scope makes sure that the bean is instantiated individually for each individual tenant of the hybris, whereas singleton would create only one instance for all tenants to use.



How much overdue time we can allow for the triggers to get fired during the server startup ?
This can be done by setting maxAcceptableDelay attribute to the Trigger.
This attribute should have the value in seconds

If its value is set as 300, then delay of 5 minutes is allowed for the overdue triggers to be fired at the server startup.

So if the trigger defines the cron expression to run the job at 5 PM , server started at 5:05 PM then above trigger will be fired(as 5 minutes of delay is accepted).

If the server started at 5:06 PM then trigger will not be fired as it does not allow the delay of more than 5 minutes.


=================================================================================================================


@SystemSetup(extension = TrainingCoreConstants.EXTENSIONNAME)
public class CoreSystemSetup extends AbstractSystemSetup
{
    public static final String IMPORT_ACCESS_RIGHTS = "accessRights";
 
    @SystemSetup(type = Type.ESSENTIAL, process = Process.ALL)
    public void createEssentialData(final SystemSetupContext context)
    {
        importImpexFile(context, "/trainingcore/import/common/essential-data.impex");
        importImpexFile(context, "/trainingcore/import/common/countries.impex");
        importImpexFile(context, "/trainingcore/import/common/delivery-modes.impex");
        importImpexFile(context, "/trainingcore/import/common/themes.impex");
        importImpexFile(context, "/trainingcore/import/common/user-groups.impex");
    }
 
       @SystemSetup(type = Type.PROJECT, process = Process.ALL)
    public void createProjectData(final SystemSetupContext context)
    {
        final boolean importAccessRights = getBooleanSystemSetupParameter(context,  
                                                                        IMPORT_ACCESS_RIGHTS);
        final List<String> extensionNames = getExtensionNames();
        if (importAccessRights && extensionNames.contains("cmscockpit"))
        {
            importImpexFile(context, "/trainingcore/import/cockpits/cmscockpit
                                                                    /cmscockpit-users.impex");
            importImpexFile(context, "/trainingcore/import/cockpits/cmscockpit
                                                             /cmscockpit-access-rights.impex");
        }
         }
}


We should add a method annotated with @SystemSetupParameterMethod inside a SystemSetup annotated class.

This method returns a list of parameters to be added


@SystemSetupParameterMethod
    public List<SystemSetupParameter> getCustomSystemSetupParameters()
    {
        final List<SystemSetupParameter> params = new ArrayList<SystemSetupParameter>();
//Adding boolean field
        final SystemSetupParameter customDataParameter = new
                                                        SystemSetupParameter("createCustomData");
        customDataParameter.setLabel("Do you want to create custom data?");
        customDataParameter.addValue("true");
        customDataParameter.addValue("false", true);
        params.add(customDataParameter);
//Adding multi select drop down box
        final SystemSetupParameter imports = new SystemSetupParameter("imports");
        imports.setMultiSelect(true);
        imports.setLabel("Custom data to import : ");
        imports.addValues(new String[]
        { "marketingGroups", "specialUsers" });
        params.add(imports);
 
        return params;
    }
	
	
================================================================================================================

"#% impex.setDumpingAllowed( true )";
$productCatalog=apparelProductCatalog
$catalogVersion=catalogversion(catalog(id[default=$productCatalog]),version[default='Staged'])[unique=true,default=$productCatalog:Staged]
UPDATE Product;code[unique=true];$catalogVersion;name;
;29531;;"Snowboard Ski Tool Toko Side Edge Angle Pro 88 Grad 1";
;29532;;"Snowboard Ski Tool Toko Side Edge Tuning Angle Pro 87 Grad 1";
;invalid_code;;"Snowboard Ski Tool Toko Side Edge Angle Pro 88 Grad 1";
;29533;;"Snowboard Ski Tool Toko Ergo Multi Guide yellow 1";


ignoring values


================================================================================================================

INSERT_UPDATE SearchRestriction;code[unique=true];name[lang=en];query;principal(UID);restrictedType(code);active;generate
;employee_restriction;Restrict employees visibility;EXISTS ({{ SELECT {pk} FROM {PrincipalGroupRelation} WHERE {source}={item:pk} AND {target} IN ( ?session.branch ) }} ) AND ( {item:active} = 1 OR EXISTS ( {{ select {ug:PK} from {UserGroup as ug} where {ug:PK} IN (?session.user.groups) and {ug:uid} = 'b2badmingroup' }} ));b2bgroup;B2BCustomer;true;true

===================================================================================================================================

How to run multiple hybris instances in one machine?
Ans. Basically, Hybris runs on a tomcat instance. Hybris is shipped with a bundled tomcat. So the question here is actually, how to run multiple tomcats in one machine.

We can run as much hybris we want, till our machine memory permits. To do so, we need to make each instance of tomcat have its own ports to use. Make the below ports unique for each instance. We should add the below properties in the local property file of each instance with unique values...

tomcat.http.port=7001


================================================================================================================================

What is the role of the jalo session?

Whenever a request comes to Hybris, the filter HybrisInitFilter creates an object of JaloSession. Every JaloSession object is associated with a SessionContext object, which has the current user, language, currency, etc and the current HTTP session object.

Cron jobs also run in a JaloSession.
Each JaloSession is bound to a tenant. This cannot be changed after the instance of JaloSession is created.
JaloSession is never made persistent in the database.  


=================================================================================================================================

Model service creates method vs new operator:

When we try to create a new instance of an item type programmatically, we have two options, using the java way, using a new operator or the hybris way, using the model service.

ProductModel product1 = new ProductModel();
ProductModel product2 = model service.create(ProductModel.class);
The advantages of using a model service method are below:
The model service creates method will generate and assign the pk for the product object.
The create method will initialize the default values, defined in items.xml for mandatory attributes.
While calling save all methods, the object is already attached to the context and will be saved. While product1 needs to attach explicitly.
So we should always go for a model service way in hybris.

====================================================================================================================================
How to split an order into multiple consignments?

By default, hybris creates only one consignment for an order. This is done by the following service.

order splitting service.

====================================================================================================================================

Their is a customize folder in the config folder generated when we run ant all at the first time, and this one is used specially to replace native SAP Hybris resources by adding custom resources in the customize folder with the same path, which means if you want to customize a file like HYBRIS_DIR/bin/platform/build.xml you need to add your custom build.xml in the following folder HYBRIS_DIR/config/customize/platform/ and then run ant customize before ant all.


To add new database external dependency properly in the platform extension, we need to replace platform HYBRIS_DIR/bin/platform/lib/dbdriver/external-dependencies.xml by a new one where the database dependency should be added to the dependencies tag.

Steps :

1 – Copy HYBRIS_DIR/bin/platform/lib/dbdriver/external-dependencies.xml in HYBRIS_DIR/config/customize/platform/lib/dbdriver/external-dependencies.xml

2 – Add the new dependency to HYBRIS_DIR/config/customize/platform/lib/dbdriver/external-dependencies.xml file

Should look like that :

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    .....
    <dependencies>
        ......
        <!--MySQL dependency-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.43</version>
        </dependency>
    </dependencies>
</project>
3 – Run customize target

/hybris/bin/platform$ ant customize

=========================================================================================================================

Hybris Run Time Config File
Starting from SAP COMMERCE 1808 Release, Hybris comes with a new tip to make properties update much easier when the server is already up and running. It’s useful most of the time for dev environment where we need to update a bunch of properties at once.

You need to add the following lines to your local.properties :

#Required (put path of your properties file)
runtime.config.file.path=/..../hybris/config/your_runtime_update_config.properties
If you want to check either your properties file is loaded or not you have to enable debug log on de.hybris.platform.util.config.FileBasedConfigLoader

#Optional
log4j2.logger.FileBasedConfigLoader.name=de.hybris.platform.util.config.FileBasedConfigLoader
log4j2.logger.FileBasedConfigLoader.level=DEBUG

==========================================================================================================================
1. Create two instances of the CompositeEntryModel :

INSERT_UPDATE CompositeEntry  ;code[unique=true]  ;executableCronJob(code)
                              ;totoCronJobEntry   ;totoCronJob
                              ;fooCronJobEntry    ;fooCronJob
2. Create an instance of the CompositeCronJobModel and attach the composite entries to it.

INSERT_UPDATE CompositeCronJob  ;code[unique=true]    ;job(code)              ;compositeEntries(code)           ;sessionUser(uid)[default=admin]  ;sessionLanguage(isocode)[default=en]
                                ;helloCompositeCronJob;compositeJobPerformable;totoCronJobEntry, fooCronJobEntry
3. Run your composite cronJob from HMc.

==============================================================================================================================

occ-->

<bean parent="fieldMapper">
        <property name="sourceClass" value="de.hybris.platform.commerceservices.search.pagedata.SearchPageData"/>
        <property name="destClass"
                  value="com.amway.indmobileoccaddon.dto.IndMobOrderHistoryPageWsDTO"/>
        <property name="fieldMapping">
            <map>
                <entry key="results" value="orders"/>             //if value is different
            </map>
        </property>
    </bean>
	
	
	 <bean parent="fieldSetLevelMapping" id="priceWsDTOFieldSetLevelMapping">
		<property name="dtoClass"
		          value="de.hybris.platform.commercewebservicescommons.dto.product.PriceWsDTO"/>
		<property name="levelMapping">
			<map>
				<entry key="BASIC" value="value,currencyIso"/>
				<entry key="DEFAULT"
				       value="currencyIso,priceType,value,maxQuantity,minQuantity,formattedValue,amwayValue(DEFAULT)"/>
				<entry key="FULL"
				       value="currencyIso,priceType,value,maxQuantity,minQuantity,formattedValue,amwayValue(FULL)"/>
			</map>
		</property>
	</bean>\\ for different scopes.
	
	
===========================================
how to call web bean in groovy-->
https://www.stackextend.com/hybris/getting-bean-from-any-context-using-groovy-script-in-hybris/

def f = ContextLoader.getDeclaredField("currentContextPerThread")
f.setAccessible(true)


ContextLoader.getDeclaredField("currentContextPerThread")
currentContextPerThread is an attribute of ContextLoader of type Map<ClassLoader, WebApplicationContext>, containing all the web application contexts.

def appContext = contexts.find {STOREFRONTCONTEXT.equals(it.key.getContextName())}
//When the context is found, we are ready to get our beans
if (appContext ==null) println "Impossible to retrieve application context"
else {
    defaultSyncService = appContext.value.getBean("synchronizationService")
}

=======================================================================================

Sometimes, it is required to define our custom item types as Catalog aware item types in order to make them eligible for synchronization.

It means we need to associate these custom item types with a catalog (content or product)

We can achieve this either in HMC/Backoffice or by defining required attributes in items.xml file.



<itemtype code="MyCustomItemType" autocreate=”true” generate=”true”>
<deployment table=" MyCustomItemType " typecode="12500"/>
   <custom-properties>
      <!-- Defining the type as synchronizing capable here: -->
      <property name="catalogItemType">
         <value>java.lang.Boolean.TRUE</value>
      </property>
 
      <!-- defining catalog version attribute here: -->
      <property name="catalogVersionAttributeQualifier">
         <value>"catalogVersion"</value>
      </property>
       
      <!-- defining unique key attributes here; separate multiple attribute qualifiers by commas: -->
      <property name="uniqueKeyAttributeQualifier">
         <value>"code"</value>
      </property>
   </custom-properties>
   <attributes>
      <attribute qualifier="code" type="java.lang.String">
         <modifiers read="true" write="true" search="true" optional="false" unique=”true”/>
         <persistence type="property"/>
      </attribute>
   
      <attribute qualifier="catalogVersion" type="CatalogVersion">
         <modifiers read="true" write="true" search="true" optional="false"/>
         <persistence type="property"/>
      </attribute>
   </attributes>
 
</itemtype>


=================================================
in custom component we have to define this on controller to pick it.

@RequestMapping(value = ControllerConstants.Actions.Cms.CustomOffersComponent)
public class CustomOffersComponentController extends AbstractCMSComponentController<CustomOffersComponentModel>



=============================================================================
$contentCatalog=myStoreContentCatalog
$contentCV=catalogVersion(CatalogVersion.catalog(Catalog.id[default=$contentCatalog]),CatalogVersion.version[default=Staged])[default=$contentCatalog:Staged]
INSERT_UPDATE CMSUserRestriction;$contentCV[unique=true];uid[unique=true];name;users(uid);components(&componentRef);&componentRef
;;AnonymousUserRestriction;Anonymous User Restriction;anonymous;LoginLink;AnonymousUserRestriction



===============================================================================

You can disable interceptor through code and Impex.

Using code
You can run your save model code using sessionService.executeInLocalViewWithParams and you can use parameters to avoid to use interceptors.

There are 3 types of policies :

InterceptorExecutionPolicy.DISABLED_INTERCEPTOR_BEANS : to disable a list of beans
InterceptorExecutionPolicy.DISABLED_INTERCEPTOR_TYPES : to disable a kind of interceptor - validator for example
InterceptorExecutionPolicy.DISABLED_UNIQUE_ATTRIBUTE_VALIDATOR_FOR_ITEM_TYPES : to disable UniqueAttributesValidatoron a set of type
Example 1 - Disable beans

final Map<String, Object> params = ImmutableMap.of(InterceptorExecutionPolicy.DISABLED_INTERCEPTOR_BEANS, ImmutableSet.of("yourDataInterceptorToDisable"));

sessionService.executeInLocalViewWithParams(params, new SessionExecutionBody()
{
    @Override
    public void executeWithoutResult()
    {
        //Do your stuff  
        modelService.save(something);   // save successful - yourDataInterceptor interceptor is disabled
    }
});
Example 2 - Disable interceptors type

final Map<String, Object> params = ImmutableMap.of(InterceptorExecutionPolicy.DISABLED_INTERCEPTOR_TYPES,
                ImmutableSet.of(InterceptorExecutionPolicy.DisabledType.VALIDATE));
sessionService.executeInLocalViewWithParams(params, new SessionExecutionBody()
{
    @Override
    public void executeWithoutResult()
    {
        //Do your stuff  
        modelService.save(something);    // save successful - all validate interceptors are disabled
    }
});
Example 3 - Disable by type

final Map<String, Object> params = ImmutableMap.of(InterceptorExecutionPolicy.DISABLED_UNIQUE_ATTRIBUTE_VALIDATOR_FOR_ITEM_TYPES, ImmutableSet.of("YourType"));

sessionService.executeInLocalViewWithParams(params, new SessionExecutionBody()
{
    @Override
    public void executeWithoutResult()
    {
        //Do your stuff  
        modelService.save(something);   // save successful - UniqueAttributesValidator not called
    }
});
Using Impex
It's the same thing with impex you can add 3 parameters to achieve the same thing as code

Example 1 - Disable beans [disable.interceptor.beans='yourDataInterceptorToDisable']

INSERT_UPDATE YourType[disable.interceptor.beans='yourDataInterceptorToDisable'];isocode[unique=true];toto;titi;
;something;toto;titi;
Example 2 - Disable interceptors type [disable.interceptor.types=validate]

INSERT_UPDATE YourType[disable.interceptor.types=validate];isocode[unique=true];toto;titi;
;something;toto;titi;
Example 3 - Disable by type [disable.UniqueAttributesValidator.for.types='YourType']

INSERT_UPDATE YourType[disable.UniqueAttributesValidator.for.types='YourType'];isocode[unique=true];toto;titi;
;something;toto;titi;


3)we can also disable all interceptors by running impex in legacy mode...
we have to just set a property in local.properties.

impex.legacy.mode=true
------------
How to disable all cron jobs running automatically in Hybris ?

We just need to add below key value pair in local.properties file


cronjob.timertask.loadonstartup=false

If its already there, make sure it is set to false.


 
Setting it to false will not allow the system to start the cron jobs automatically after server restart and thus increases the system performance.

+sign in hot folder it is mandatory.



=========================================================================================================================

The following code snippet shows how to disable all validate interceptors so that you can save the data successfully. Currently, this method only supports the validator type interceptors:
final Map<String, Object> params = ImmutableMap.of(InterceptorExecutionPolicy.DISABLED_INTERCEPTOR_TYPES,
                ImmutableSet.of(InterceptorExecutionPolicy.InterceptorType.VALIDATE));
sessionService.executeInLocalViewWithParams(params, new SessionExecutionBody()
{
    @Override
    public void executeWithoutResult()
    {
        final CurrencyModel currency = modelService.create(CurrencyModel.class);
        currency.setSymbol("$");
        currency.setIsocode("Dollar");
        currency.setDigits(-1);
         
        modelService.save(currency);    // save successful - all validate interceptors are disabled
    }
});

==========================================================================================================================
develop: This template is optimized for use in a development environment, where you use your SAP Commerce installation internally only, and it undergoes frequent changes. In such an environment, performance and debugging aspects generally rank higher than security.

production: This template is optimized for use in a production environment, where your SAP Commerce installation is available to external users. In this environment, security is the priority, and the installation requires more system memory than it does in a development configuration. Changes are few in number, usually when deploying software updates. This template does not contain configuration files for debugging operations in your application server.


==================================================================================

It is mandatory to intercept interceptors with model to work.

<!-- Mapping Interceptor and model class-->
<bean id="consignmentPrepareInterceptorMapping" class="de.hybris.platform.servicelayer.interceptor.impl.InterceptorMapping">
        <property name="interceptor" ref="consignmentPrepareInterceptor"/>
        <property name="typeCode" value="Consignment"/>
    </bean>


----------------------------------
if itemtype not extending any existing type autocreate=true ,deployment table and code should be done.

If we set it autocreate false,build will fail.
We should set it to true for the first definition of item type.


while extending some other type deployment table should not be preferred but autocreate always.
===========================================================================
Insert_update Employee;sessionLanguage(isocode)
;en

here sessionLanguage(isocode) it is a foreign key which will fetch object of language whose isocode is en and attach to employee.


when we use mode=append in impex dont forget to use oldvalue,newvalue ---//otherwise it will replace

----------
inserting map values via impex...-->

INSERT_UPDATE SolrIndexedProperty;solrIndexedType(identifier)[unique = true];name[unique = true];valueProviderParameters[map-delimiter=|]

;lynxContentPageType; content_segmentationleveltypeenum_9 ; businessNature->AMWAYBUSINESSNATURE_1|segmentationLevel->SEGMENTATIONLEVELTYPEENUM_9 


here valueprovider parametre is a map
<maptype code="ValueProviderParametersMapping" argumenttype="java.lang.String" returntype="java.lang.String" />

we r using delimiter to insert multiple values....

----------
for impex export we can take help of script generator in backoffice and copy the required code.


-------------------------------------------------------------------------------------------
if we are creating extension and we want to create it on a particular path.

just change this property.

extgen.extension.path=${HYBRIS_BIN_DIR}/custom/training

either in local or project.properties inside extgen of platform folder.

also u can change default extension in this properties file.

-----------------------------------------------------------------------------------
to check the hybris version just go to any extension resources and open file with name like trainingocc.build.number.

-------------------------------------------------------------------------------------

Make custom extension as Extension Template

We can make our custom extension also as extension template so that it appears in the list of extension templates during ant extgen command

To achieve this , we need to define the below tag in extensioninfo.xml

meta key="extgen-template-extension" value="true"

Adding this enables our extension to appear in the ant extgen command templates list.

-----------------------------------------------------------------------------------------------
addon-->
addon always have extra folder name as acceleratoraddon.which will be copied in storefront addonsrc inside web.

ant addoninstall -Daddonnames="trainingaddon" -DaddonStorefront.storefrontTemplateName="trainingstorefront"

--------------------------------------------------------------------------------------------------
items.xml-->

autocreate = true--->while initializtion this type will insert into database automatically.
generate = true ---->corrosponding jalo class will create automatically.
localized =true  --->will be available in multiple languages.
persistence=dynamic ---->it will store in hybris memory and when server is down it got washed.
part-of=true        ---->Cascade delete,Defines if the assigned attribute value only belongs to the current instance of this type. Default is 'false'.
removable = true    ---->Defines if this attribute is removable. Default is 'true'.
isSelectionOf="string" [0..1]  --->References an attribute of the same type. Only values of the referenced attribute can be selected as values for this attribute. Typical example: the default delivery address of a customer must be one of the addresses set for the customer. 
Default is 'false'.

Example-->
 <attribute autocreate="true" qualifier="shippingAddresses" type="AddressCollection">
               <modifiers read="true" write="false" search="false" optional="true" partof="true"/>
               <persistence type="dynamic"/>
            </attribute>
				<attribute qualifier="shippingAddress" type="Address" isSelectionOf="shippingAddresses">
					<description>Shipping address of this company</description>
					<modifiers read="true" write="true" search="true" optional="true"/>
					<persistence type="property"/>
				</attribute>


initial="boolean"--->If 'true', the attribute will only be writable during the item creation. Setting this to 'true' is only useful in combination with write='false'. Default is 'false'.




<attribute autocreate="true" qualifier="calculated" type="java.lang.Boolean" generate="true">
    <custom-properties>
        <property name="modelPrefetchMode">
            <value>java.lang.Boolean.TRUE</value>
        </property>
    </custom-properties>
    <defaultvalue>java.lang.Boolean.FALSE</defaultvalue>
    <persistence type="property"/>
    <modifiers read="true" write="true" search="true" optional="true"/>
    <model>
        <getter default="true" name="calculated">
            <nullDecorator>Boolean.valueOf(false)</nullDecorator>
        </getter>
    </model>
</attribute>
You can use the nullDecorator tag to specify an expression that is put inside the generated method of the AbstractOrderModel class. In this case, we prefer to get false instead of null. If you generate model classes, you can verify the code of the getCalculated method of the AbstractOrderModel class:
public Boolean getCalculated()
{
   final Boolean value = getPersistenceContext().getPropertyValue(CALCULATED);
   return value != null ? value : Boolean.valueOf(false);
}




attribute-level custom-properties: they are used to mark a specific behaviour of the attribute e.g.

 <attribute qualifier="internalURL" type="java.lang.String">
     <custom-properties>
         <property name="hiddenForUI">
             <value>Boolean.TRUE</value>
         </property>
     </custom-properties>
     <modifiers read="true" write="true" search="false" optional="true"/>
     <persistence type="property">
         <columntype>
             <value>HYBRIS.LONG_STRING</value>
         </columntype>
     </persistence>
 </attribute>
Due to the configuration of hiddenForUI, the attribute, internalURL of the itemtype, Media is not visible in the backoffice.
Backoffice Custom Attributes- Backoffice would allow to display all attributes of any type (out of the box), nevertheless there are some special (let's say technical) attributes that definitely should not be visible in the UI or should at least be readonly in the UI (no matter what the access rights they have). For those very rare case hybris have introduced two custom attributes that we interprete when the typesystem is scanned
    <property name="readOnlyForUI">
       <value>Boolean.TRUE</value>
    </property>
    <property name="hiddenForUI">
       <value>Boolean.TRUE</value>
    </property>

'
<relation code="User2Addresses" generate="true" localized="false" autocreate="true">
    <sourceElement type="User" cardinality="one" qualifier="owner">
        <modifiers read="true" write="true" search="true" optional="true" initial="false"/>
    </sourceElement>
    <targetElement type="Address" cardinality="many" qualifier="addresses">
        <modifiers read="true" write="true" search="true" optional="true" partof="true"/>
        <custom-properties>
            <property name="condition.query">
                <value>"{original} is null"</value>
            </property>
        </custom-properties>
    </targetElement>
</relation>

The property holds a string that is later added to the 'where' part of the select query generated for a one-to-many or many-to-one relation.



===================================================================================================================================
Flexible search-->
We dont use TableName in flexible search we just use item type code.

flexible search query has an advantage over mysql it will not hit database again on a particular interval if we hit same query.

select {name[de]} from {Product}

will give particular local specific name.

select * from {Product!}   it will not give child.


=======================================================================================================================================
business process points-->

order process call from submit order event..
it go to wait in splitorderaction.
in this consignment process start and trigger the event from sub process end action.

<timeout delay ="121212" then="timeout">   /////it will timeout and redirect to node if wait fails in time.
<split>  //if we want to run two action at a time.
<targetnode ="1"><targetnode ="2">            //calling respective action.
</split>                   

on which node we want to run/or not run business process.we will add this propety in properties file.
task.eingine.loadonstartup = true/false                  
			 
			 
Retry mechanism in business process--->
to rerun the task in specific interval of time.

scenerio....
not getting response from third party so we will retry it sometimes to get response in last send to error.

we just have to throw retryLaterException,than hybris ootb rerun the task.

so we need to check how many time we have to retry task......we can also customize this using business process parametre.

here we will set value in business process parametre...and increment it every time when retry happen..and check the count to stop.

we will use getProcessParameterHelper().setBusinessProcessParamter() ////method to set and vice vers to get.
=============================  ==========================================================================================================
Some points on hotfolder-->

we can change our comparator also we can set priority.

<bean id="marketplaceFileOrderComparator" class="de.hybris.platform.acceleratorservices.dataimport.batch.FileOrderComparator">
		<property name="prefixPriority">
			<map>
				<!-- default priority is 0 -->
				<entry key="marketplace_base_product" value="2" />
				<entry key="marketplace_apparel_base_product" value="2" />
			</map>
		</property>
	</bean>



<bean id="batchStyleVariantConverter" class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.impl.DefaultImpexConverter">
		<property name="header">
			<value>#{defaultImpexProductHeader}
				$baseProduct=baseProduct(code,$catalogVersion)  //seetting headres
				# Insert style variant specific data
				INSERT_UPDATE ApparelStyleVariantProduct;$baseProduct;code[unique=true];variantType(code);style[lang=$lang];sequenceId[translator=de.hybris.platform.acceleratorservices.dataimport.batch.converter.SequenceIdTranslator];$catalogVersion;$approved
			</value>
		</property>
		<property name="impexRow">
			<value>;{+0};{+1};{2};{3};{S}</value>
			//+ sign madatory  ,S means it will append some value on file after processing or error
		</property>
		<property name="rowFilter">
			<bean class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.impl.DefaultImpexRowFilter">
				<property name="expression" value="row[2] == 'ApparelStyleVariantProduct' || (!row[2] &amp;&amp; !row[4])"/>
			</bean>
		</property>
	</bean>



<bean id="fabStoreMediaContainerConverterMapping" class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.mapping.impl.DefaultConverterMapping"
		  p:mapping="zip_fabstoremedia" p:converter-ref="fabStoreMediaContainerConverter"/>

===============================================================================
in hybris batch mode-->
1)if we will use attribute itemtype(code) in impex it will run on whole.
2)if we use specific attribute and give value in impex it will run only on those values.

# Update All Products of powertoolsProductCatalog Staged version
UPDATE Product[batchmode=true]; $catalogVersion; minOrderQty ; maxOrderQty
;;1;99

======================================================================================================================
Search restriction-->add where clause in flexible search
 here we have a 
 restiction type---->on which type we have to put restriction.
 (query)filter---> if the condition fullfill than show result in (flexible)search.
 (Apply on)group----> on which group it will run.we cannot put on admin.

they also dont get applied on external search eingine there we will use flexible filter.

=================================================================================================================================
Assign all the cronjobs to a specific node group. Let us call the node group as ‘backoffice’.
INSERT_UPDATE CronJob;code[unique=true];job(code);nodeGroup
;myCustomCronJob;myCustomJob;backoffice
Add the below property to the local.properties file of the cluster nodes where you would like to run the CronJobs.
cluster.node.groups=backoffice

When a job is fired by a trigger, a CronJob instance is automatically created, because each execution needs a CronJob instance to provide the configuration.

Assigning a cronjob to a group of nodes will only work if you assign a trigger to your cronjob!

The task engine is what will pick up the node to execute the cronjob based on the nodegroup setting not the cronjob itself.

Programatically executing cronjobs without a trigger would execute on the current node or on a specific node by node id.

Cron Job manual run ignores nodeGroup


==========================================================================================================================
A JaloSession is always associated with a SessionContext which holds references to the following:
JaloSession's User
JaloSession's Language
JaloSession's Currency
JaloSession's Pricefactory
JaloSession's Locale
JaloSession's Timezone
During the JaloSession's instantiation, the SessionContext is pre-set with system defaults, which depend on the current tenant. The factory default user account is anonymous.

To access the JaloSession assigned to a thread, call the static JaloSession.getCurrentSession() method. This method does the following:
Returns the currently active JaloSession.

Creates a new JaloSession if none is currently active.

===========================================================================================================================
<attributes>
                    <attribute qualifier="size" type="localized:java.lang.String" >
                        <description>Size of the product.</description>
                        <modifiers initial="true" optional="true" write="false"/>
                        <persistence type="property"/>
                    </attribute>
                </attributes>   //setter will be generated. in intial = true
				
				
				
				 <attributes>
                    <attribute qualifier="size" type="localized:java.lang.String" >
                        <description>Size of the product.</description>
                        <modifiers optional="false" write="false"/>    //we must have to put default value or initial = true otherwise error
                        <persistence type="property"/>
                    </attribute>
                </attributes>
				
				
				<modifiers initial="true" optional="false" write="false"/> // it has no significance as it is already maadatory.
				
				
				initial = "true" means that you definitely need to fill out this attribute when creating the model. Otherwise, you cannot save the model.

It’s very important to do so for the attributes that can be used as indexes in the database, such as product code, UID, etc.

The advantage of using this modifier is data management. You can be sure that when creating new objects, this attribute is filled.

It’s also good practice to use initial="true" with a default value.

It’s especially relevant for boolean values. To avoid the setting null to the boolean field, you can define a default value "true" or "false" for this field.

============================================================================================================================
setting default value of a map-->


<items xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="items.xsd">

    <maptypes>
        <maptype code="DummyMap"
                 argumenttype="java.lang.String"
                 returntype="java.math.BigInteger"
                 autocreate="true"
                 generate="false"/>
    </maptypes>
    <itemtypes>
        <itemtype code="DummyItem" autocreate="true">
            <deployment table="DummyItem" typecode="30001" />
            <attributes>
                <attribute qualifier="uname" type="java.lang.String">
                    <modifiers read="true" write="true" search="true" initial="true" optional="false"/>
                    <defaultvalue>"Hello"</defaultvalue>
                    <persistence type="property"></persistence>
                </attribute>
                <attribute qualifier="dummyAttribute" type="DummyMap">
                    <modifiers read="true" write="true" search="true" initial="true" optional="false"/>
                    <defaultvalue>java.util.Collections.singletonMap("one", java.math.BigDecimal.ONE)</defaultvalue>
                    <persistence type="property"></persistence>
                </attribute>
            </attributes>
        </itemtype>
    </itemtypes>
</items>

===========================================================================================================================
=====================================================================================================================
final FlexibleSearchQuery ewayBillQuery = new FlexibleSearchQuery(ewayQuery.toString(), queryParams);
		ewayBillQuery.setResultClassList(Arrays.asList(OrderModel.class, String.class, AddressModel.class, Double.class, Double.class));
		final SearchResult<List<Object>> result = flexibleSearchService.search(ewayBillQuery);

		final FlexibleSearchQuery ewayBillInvoiceQuery = new FlexibleSearchQuery(ewayInvoiceQuery.toString(), queryParams);
		ewayBillInvoiceQuery.setResultClassList(Arrays.asList(AmwayInvoiceModel.class, Date.class, AmwayInvoiceEntryModel.class));
		final SearchResult<List<Object>> invoiceResult = flexibleSearchService.search(ewayBillInvoiceQuery);

		final Map<String, Double> finalRecord = new LinkedHashMap<>();
		final Map<String, List<AmwayInvoiceEntryModel>> validRecords = new LinkedHashMap<>();
		final Map<RegionModel, IndEwayBillConfigModel> configMapping = new LinkedHashMap<>();

		List<List<Object>> records = result.getResult();
		List<List<Object>> invoiceRecords = invoiceResult.getResult();
		List<List<Object>> collaboratedResults = new ArrayList<>();
		
		
object in flexible search....
=========================
adding product into cart....-->

method used-->
 CartModificationData addToCart(final String code, final long quantity)   //we will pass code of product and quantity.
 
 than we will create params-->
 
 final AddToCartParams params = new AddToCartParams();
		params.setProductCode(code);
		params.setQuantity(quantity);

		return addToCart(params);
		

than we will create --->CommerceCartParameter from AddToCartParams-->

final CommerceCartParameter parameter = getCommerceCartParameterConverter().convert(addToCartParams);

inside converter some logic will go like this-->

if (addToCartParams.getProductCode() != null)
		{
			final ProductModel product = getProductService().getProductForCode(addToCartParams.getProductCode());
			parameter.setProduct(product);
			parameter.setUnit(product.getUnit());
		}
		parameter.setQuantity(addToCartParams.getQuantity());
		


at last we will use -->
final CommerceCartModification modification = getCommerceCartService().addToCart(parameter); //which will add data in cart.

inside that method-->
final CommerceCartModification modification = doAddToCart(parameter);
		getCommerceCartCalculationStrategy().calculateCart(parameter);
		afterAddToCart(parameter, modification);
		// Here the entry is fully populated, so we can search for a similar one and merge.
		mergeEntry(modification, parameter);
		return modification;
		
		
CommerceCartModification---> this is return every time when we update any cart and have updated data.
=========================================================================================================================================
cart merging in hybris-->

Technical:

Bascially in hybris , Cart Merging functionlity has provided by using CommerceCartMergingStrategy where a method mergeCarts() is responsible for merging the cart

void mergeCarts(CartModel fromCart, CartModel toCart, List<CommerceCartModification> modifications) throws CommerceCartMergingException;
fromCart – Cart from merging is done
toCart- Cart to merge to
modifications – List of modifications


In facade level(commerceFacade) there two method which used for merge cart

1. CartRestorationData restoreAnonymousCartAndMerge(String fromAnonumousCartGuid, String toUserCartGuid)
throws CommerceCartMergingException, CommerceCartRestorationException;
> Merging from anonymous user cart to logged in user cart

2. CartRestorationData restoreCartAndMerge(String fromUserCartGuid, String toUserCartGuid)
throws CommerceCartRestorationException, CommerceCartMergingException;
> Both cart of same user


Important point should know about Cart Merge:

1. You can merge an anonymous cart with a registered cart, but you cannot merge a registered cart with an anonymous cart.
2. You can merge a non-empty anonymous cart with a non-empty registered cart.
3. If the same item is in the anonymous cart and the registered cart, the quantities are added together when the two carts are merged.
4. If the same item, one with an itemYrn is in the anonymous cart and the other with a product object is in the registered cart, the items are added as separate entries when two carts are merged. The quantities are not added together.
5. You can merge two empty carts with different currencies. When the two carts are merged, the new cart assumes the currency of the registered cart.
6. You can merge two non-empty carts with different currencies even if the items in the anonymous cart does not have prices in the currency of the registered cart.
7. You can merge two carts if the price of the item in the cart has been updated.
8. You can merge two carts if an item in the cart is currently out of stock, but this will prevent the customer from proceeding to checkout. If the customer attempts to perform a checkout, an error message displays prompting the customer to remove that item from their cart.
9. You can merge two carts if the price for an item in the cart has been deleted, but this will prevent the customer from proceeding to checkout. If the customer attempts to perform a checkout, an error message displays prompting the customer that the price of the product does not exist.
===========

points on populator and converter--->

 <bean parent="modifyPopulatorList">
        <property name="list" ref="defaultProductConverter"/>
        <property name="add" ref="lynxProductStockPopulator"/>
    </bean>
	
	-----------
	<bean id="indProductConfiguredPopulator" parent="lynxAccProductConfiguredPopulator">
        <property name="populators">
            <map key-type="de.hybris.platform.commercefacades.product.ProductOption" merge="true">
                <entry key="MIN_STOCK_THRESHOLD" value-ref="indProductMinStockThresholdPopulator"/>  /key in data option
            </map>
        </property>
    </bean>


getProductConfiguredPopulator().populate(productModel, productData, options);


when to use convertAll?

when we have a list to convert of model to data...than we will use

target.setEntries(indConsignmentEntryPayloadConverter.convertAll(source.getConsignmentEntries())); //here converting enteries.


=====================================================================================
INSERT DynamicProcessDefinition; code;content; active[default=true]
;consignment-process-rdpickup-my-v3;"<process xmlns='http://www.hybris.de/xsd/processdefinition' start='checkState' name='consignment-process-rdpickup-my-v3' processClass='de.hybris.platform.ordersplitting.model.ConsignmentProcessModel'> <action id='checkState' bean='lynxCheckStateAction'> <transition name='OK' to='sendConsignmentToWarehouse'/> <transition name='SHIPPED' to='shipConsignment' /> <transition name='LINE_DISPOSITION' to='triggerOrderComplete' /> <transition name='WAIT' to='waitForRelease' /> <transition name='NOK' to='failed' /> <transition name='VDS' to='sendEmailToVendor'/> <transition name='CANCELLED' to='success'/> </action> <wait id='waitForRelease' then='checkState' prependProcessCode='false'> <event>${process.consignment.code}_WaitForRelease</event> </wait> <action id='sendConsignmentToWarehouse' bean='lynxSendConsignmentToWarehouseAction'> <transition name='OK' to='waitForWarehouse'/> <transition name='NOK' to='failed' /> </action> <action id='consignmentRDReadyForPickupSMSNotification' bean='lynxConsignmentRDReadyForPickupSMSNotificationAction'> <transition name='OK' to='changeOrderStatus'/> </action> <wait id='waitForWarehouse' then='checkState' prependProcessCode='false'> <event>${process.consignment.code}_WaitForWarehouse</event> </wait> <action id='sendEmailToVendor' bean='lynxSendEmailToVendorAction'> <transition name='OK' to='shipConsignment'/> <transition name='NOK' to='failed'/> </action> <action id='shipConsignment' bean='lynxShipConsignmentAction'> <transition name='OK' to='consignmentRDReadyForPickupSMSNotification' /> <transition name='NOK' to='failed' /> </action> <action id='changeOrderStatus' bean='lynxChangeOrderStatusAction'> <transition name='OK' to='generateMasterCode' /> <transition name='NOK' to='failed' /> </action> <action id='generateMasterCode' bean='lynxGenerateMasterCodeAction'> <transition name='OK' to='sendShipmentEvent'/> <transition name='NOK' to='failed' /> </action> <action id='sendShipmentEvent' bean='lynxSendShipmentEventAction'> <transition name='OK' to='invoiceConsignment'/> <transition name='NOK' to='failed' /> </action> <action id='invoiceConsignment' bean='lynxMSBInvoiceConsignmentAction'> <transition name='OK' to='triggerOrderComplete'/> <transition name='NOK' to='failed' /> </action> <action id='triggerOrderComplete' bean='lynxTriggerOrderCompleteAction'> <transition name='OK' to='success'/> </action> <end id='success' state='SUCCEEDED'>Consignment Process Successful.</end> <end id='failed' state='FAILED'>Consignment Process Failed.</end> <end id='error' state='ERROR'>Consignment Process In Illegal State.</end> </process>";

use to make a dynamic process if we want to change something just add in content and repair business process.

======================================================================================
we can redeclare parent attribute in child itemtype by using redeclare attribute and can change its type.

=======================================================================================
properties to add server in debug mode 

tomcat.javaoptions=-Dorg.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=true -Dorg.apache.cxf.Logger=org.apache.cxf.common.logging.Log4jLogger -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv4Addresses=true -Djava.net.preferIPv6Stack=false -Djava.net.preferIPv6Addresses=false

tomcat.debugjavaoptions=-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,address=8787,suspend=n ${tomcat.javaoptions}

tomcat.generaloptions=-Xmx3G -XX:MaxPermSize=1024M -ea -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dorg.tanukisoftware.wrapper.WrapperManager.mbean=true -Djava.endorsed.dirs="%CATALINA_HOME%/lib/endorsed" -Dcatalina.base=%CATALINA_BASE% -Dcatalina.home=%CATALINA_HOME% -Dfile.encoding=UTF-8 -Dlog4j.configuration=log4j_init_tomcat.properties -Djava.util.logging.config.file=jdk_logging.properties -Djava.io.tmpdir="${HYBRIS_TEMP_DIR}" -Xverify:none -Dtomcat.minimal.webapps=hmc


=======================================================================
on which node we want to run/or not run business process.we will add this propety in properties file.
task.eingine.loadonstartup = true/false     

build.development.mode=false


cronjob.timertask.loadonstartup=false


Add the below property to the local.properties file of the cluster nodes where you would like to run the CronJobs.
cluster.node.groups=backoffice
===============================================
https://help.sap.com/viewer/d0224eca81e249cb821f2cdf45a82ace/1905/en-US/8b6ded0d86691014a6fab18e171c1f91.html

https://help.sap.com/viewer/b490bb4e85bc42a7aa09d513d0bcb18e/1905/en-US/8b89e9f986691014a915c84d1067b6ee.html



============================================================================================================================================
-------------------------------------


deleting products and do indexing via code--->


 try
            {
                tx = Transaction.current();
                tx.begin();
                getModelService().removeAll(productModelListToBeDeleted);
                tx.commit();
            }
            catch (final ModelRemovalException e)
            {
                if (null != tx)
                {
                    tx.rollback();
                }
                LOG.error("Could not remove the product list -->" + e);
            }


 final SolrFacetSearchConfigModel facetSearchConfigModel = baseSiteService.getBaseSiteForUID(SITE_UID)
                    .getSolrFacetSearchConfiguration();
            final FacetSearchConfig facetSearchConfig = facetSearchConfigService.getConfiguration(facetSearchConfigModel.getName());
            indexerService.performFullIndex(facetSearchConfig);


//fetching solarfacetsearchconfiguration from site and then performing full indexing...
=========================================================================================================================================
Cronjob-->

Running cronjob through code rather than trigger?

ProductsRemovalCronJobModel  productsRemovalCronJobModel =modelService.create(ProductsRemovalCronJobModel.class);
 
// assign Job to CronJob
ServicelayerJobModel  servicelayerJobModel = modelService.create(ServicelayerJobModel.class);
servicelayerJobModel.setActive(true);
servicelayerJobModel.setSpringId("productsRemovalJob");
productsRemovalCronJobModel.setJob(servicelayerJobModel);
modelService.save(productsRemovalCronJobModel);
cronJobService.performCronJob(productsRemovalCronJobModel);

TaskEngine: For every trigger there is always one Task item gets created in Hybris.

TaskEngine will keep on polling the Tasks for every X seconds which we configure in the local.properties file as below


cronjob.trigger.interval=30
By default the timer is set to 30 seconds, so if we want to change this value we can define it with new value in the local.properties file as mentioned above.

Here X is 30 seconds, so for every 30 seconds Timer task fires a DB query to check for any triggers to be fired , if any triggers matches the current time or its overdue then Trigger is fired immediately.


in cronjob we can-->
1) Set the session attributes through impex



INSERT_UPDATE CronJob;code[unique=true];job(code);sessionUser(uid);sessionLanguage(isocode);sessionCurrency(isocode)
 
;myCronJob;myJob;user1;en;EUR


2) Set the session attributes through code

CronJobModel myCronJob=modelService.create(CronJobModel.class);
 
// set JobModel to CronJobModel
 
myCronJob.setSessionUser(mySessionUserModel);
 
myCronJob.setSessionLanguage(mySessionLanguage);
 
myCronJob.setSessionCurrency(mySessionCurrency);
 
modelService.save(myCronjob);
 
cronJobService.performCronJob(myCronJob);


-------------------------------------------------------

passing parametres in flexible search-->

final Map<String, Object> params = new HashMap<String, Object>();
String query =”SELECT {p:pk} FROM {Product AS p} WHERE {p:code} LIKE ?code”
params.put("code",”001”);
final SearchResult<ProductModel> searchResult = flexibleSearchService.search(query, params);


===================================================================================================
@CacheControl(directive = CacheControlDirective.PRIVATE)

--> it is class level annotation which tells the response message is intended for a single user and MUST NOT be stored by a shared cache.

@CacheControl(directive = CacheControlDirective.PRIVATE)

NO_TRANSFORM--->response can noot be modified with cache.

NO_STORE ---->cache MUST NOT store any part of either the immediate request or response.

NO_CACHE --->response MUST NOT be used to satisfy a subsequent request without successful validation on the origin server.

==============================
INSERT_UPDATE Trigger;cronJob(code)[unique=true];second;minute;hour;day;month;year;relative;active;maxAcceptableDelay
;aqwikcilverAuthTokenUpdateCronJob;-1;-1;-1;6;-1;-1;true;true;-1
;agravityAuthTokenUpdateCronJob;0;30;3;-1;-1;-1;true;true;-1

relative = true for every 3.30 hour cron


=============================================
INSERT Region;country(isocode);isocode[unique=true];active
#% beforeEach: if( FlexibleSearch.getInstance().search("SELECT {pk} FROM {Region} WHERE {isocode} = ?isocode", Collections.singletonMap( "isocode", line.get(2)), de.hybris.platform.jalo.c2l.Region.class).getCount() > 0 ) line.clear() ;
;IN;IN-01;false


it will check if count of isocode is 2 clear one of them.

------------------------------------------------------------------------------------------------------------------
<persistence type="property">
							<columntype>
								<value>HYBRIS.LONG_STRING</value>
							</columntype>
						</persistence>
						
						to increase length of column
						
-------------$targetType=PriceRow
REMOVE $targetType[batchmode=true];itemtype(code)[unique=true]
;$targetType


=============================================

INSERT_UPDATE SyncAttributeDescriptorConfig; syncJob(code)[unique = true][path-delimiter = !]; attributeDescriptor(enclosingType(code), qualifier)[unique = true]; copyByValue;

                                           ; sync fabindia-b2cProductCatalog:Staged->Online  ; Product:sizeChart                                             ; true

when we have error in sync on itemtype


============================================================================================
Flexible Search Example-->
https://help.sap.com/viewer/d0224eca81e249cb821f2cdf45a82ace/1905/en-US/8bc36ba986691014b48be171221d1f4f.html


=================================================================================================
adding new solr filter

target.getSearchQuery().addFilterQuery(FIELD_NAME, String.valueOf(Boolean.FALSE));


final query generated in 
DefaultFacetSearchStrategy

===================================================================================================
@Override

    public void saveFranchiseInfo(FabFranchiseEnquiryData franchiseEnquiryData) throws DuplicateUidException {

        FabFranchiseEnquiryModel enquiryModel = getFabFranchiseEnquiryReverseConverter().convert(franchiseEnquiryData);

        try {

            getModelService().save(enquiryModel);

        }

        catch (final ModelSavingException e)

        {

            if (e.getCause() instanceof InterceptorException

                    && ((InterceptorException) e.getCause()).getInterceptor().getClass().equals(UniqueAttributesInterceptor.class))

            {

                throw new DuplicateUidException(MessageFormat.format("Same record exists with {0} and {1}", enquiryModel.getEmail(), enquiryModel.getMobile()), e);

            }

            else

            {

                throw e;

            }

        }

        catch (final AmbiguousIdentifierException e) {

            throw new DuplicateUidException(MessageFormat.format("Same record exists with {0} and {1}", enquiryModel.getEmail(), enquiryModel.getMobile()), e);

        }

    }
	
	good approach when we have a saving exception on duplicate.
	
==============================================================================================================================================

Export via flexibleSearchService

INSERT_UPDATE product;code;creationtime;modifiedtime
  "#%impex.exportItemsFlexibleSearch(""select {pk} from {product as p join catalogVersion as cv on {p.catalogVersion}={cv.pk} join Unit as u on {p.unit}={u.pk}} where {cv.version} = 'ERP_IMPORT'"");"
  
  =========================================================================================
  CMSNavigationNode me restrictions nh hoti

to USD me hme 4 node dikhane the

INR me saaare


INSERT_UPDATE SearchRestriction;code[unique=true];name[lang=en];query;principal(UID);restrictedType(code);active;generate
                               ;fab_b2c_navigation_nodes_anonymous_restriction;Anonymous Restrict category Navigation nodes based on session currency ;({item:uid} != 'FurnitureNode' AND {item:uid} != 'BeautyNode' AND {item:uid} != 'FoodNode') OR  (EXISTS ({{ select {ug:PK} from {UserGroup as ug} where {ug:PK} IN (?session.user.groups) and {ug:uid} != 'anonymous' }} ) OR EXISTS ( {{ select {c:PK} from {Currency as c} where {c:PK} IN (?session.currency) and {c:isocode}='INR'}} ));anonymous;CMSNavigationNode;true;true
INSERT_UPDATE SearchRestriction;code[unique=true];name[lang=en];query;principal(UID);restrictedType(code);active;generate
                               ;fab_b2c_navigation_nodes_customer_restriction;Customer Restrict category Navigation nodes based on session currency ;({item:uid} != 'FurnitureNode' AND {item:uid} != 'BeautyNode' AND {item:uid} != 'FoodNode') OR  (EXISTS ({{ select {ug:PK} from {UserGroup as ug} where {ug:PK} IN (?session.user.groups) and {ug:uid} != 'customergroup' }} ) OR EXISTS ( {{ select {c:PK} from {Currency as c} where {c:PK} IN (?session.currency) and {c:isocode}='INR'}} ));customergroup;CMSNavigationNode;true;true
							   
							   
===============================================

Map<String, Set<Locale>> dirtyAttributes = interceptorContext.getDirtyAttributes(productModel);

//////dirty attributes give all the information whatever we change in the model ....which we can fetch from context..


=============================================================================================================
After the cancellation order, Hybris creates duplicate order with the same status as it was before the cancellation. So we have 2 orders with 2 statuses.

I'd like to have only 1 entry in result. How it's possible?

This can be done in 2 ways.

Search Restriction on customersupportagentgroup or related group.

INSERT_UPDATE SearchRestriction;code[unique=true];principal(uid)[unique=true];query;restrictedType(code)[unique=true];active;generate

;backendOrderVisibility;customersupportagentgroup;{versionID} IS NULL;Order;true;true

create new Controller to send extra filter which will give result of orders which having version id null, this is part of backoffice customization. --->Create custom controller and extend this AbstractInitAdvancedSearchAdapter and override addSearchDataConditions. ---->Create definition.xml -----> ovverride widget connection as well.

=======================================================================================================================================

https://hybrisdiary.wordpress.com/2016/09/06/what-is-the-use-productoption-enum-in-hybris/

========================================================================================================================================

https://stackoverflow.com/questions/66600283/hybris-solr-text-fuzzy-wildcard-and-phrase-free-text-query

======================================================================

SELECT count(*) FROM { Customer as c JOIN Address as a ON {c:PK} = {a:owner}} where {a.region} is null

============================================================================
When you create a new Promotion Engine rule group, the exclusivity field is set to false. This means that all promotion rules in the group applies to a cart. To have only one promotion rule in the group to apply to a cart, set the exclusivity field to true and republish all promotion rules in the promotion rule group.
===============================================================
defaultPassword=12341234
INSERT_UPDATE UserGroup ; UID[unique=true]   		 ; groups(uid)[mode=append] 					 ; description                  			; name
                        ; fabindiacustomercaregroup	 ; itemlockinggroup,employeegroup            ; FAB India Customer Access Group     	; FAB India Customer Access Group
						
						
						
INSERT_UPDATE BackofficeRole; UID[unique = true] 		 ; groups(uid)[mode = append]		; locName              				     ; name                 					; backOfficeLoginDisabled
                            ; backofficecustomercarerole ; fabindiacustomercaregroup        ; Backoffice Fab Customer Care User Role ; Backoffice FAB Customer Care User Role   ; FALSE
							
							
							
INSERT_UPDATE Employee; UID[unique = true]      ; groups(uid)[mode = append]  		; password[default=$defaultPassword]
                      ; fabcustomercare         ; backofficecustomercarerole        ;
					 
					 
$START_USERRIGHTS
Type;UID;MemberOfGroups;Password;Target;read;change;create;remove;change_perm;;
UserGroup;fabindiacustomercaregroup;employeegroup;;;;;;;;;
;;;;Product;+;-;-;;;;
;;;;CatalogVersion;+;-;-;;;;
;;;;Catalog;+;-;-;;;;
;;;;Category;+;-;-;;;;
;;;;ProductPromotion;+;-;-;;;;
;;;;InboxView;+;-;-;;;;
;;;;UserGroup;+;-;-;;;;
$END_USERRIGHTS



=================
class Test {
    public static void main(String[] args) {
        int[] a = {1, 2, 3, 4};
        int[] b = {2, 3, 1, 0};
        System.out.println(a[(a = b)[3]]);
    }
}

print 1

-------------------------------
What Is Role Of Jalosession?

Answer :

The Jalo layer in hybris is depreacted, not the jalosession.

Whenever a request is made to hybris server, it may need current user details, currency, language, timezone etc to serve that request efficiently. Since HttpSession does not hold all these details, hybris came up with the concept of JaloSession.

Whenever a request comes to Hybris, the filter HybrisInitFilter creates an object of JaloSession. Every JaloSession object is associated with a SessionContext object, which has current user, language, currency etc and the current httpSession object.

Cron jobs also run in a JaloSession.
Each JaloSession is bound to a tenant. This cannot be changed, after the instance of JaloSession is created.
JaloSession is never made persistent in database.

===================================

How to add any bean to Map

<bean depends-on="processContextResolutionStrategyMap" parent="mapMergeDirective" >
		<property name="key" >
			<value type="java.lang.Class">de.hybris.platform.b2bacceleratorservices.model.process.ReplenishmentProcessModel</value>
		</property>
		<property name="value" ref="b2bProcessContextStrategy" />
	</bean>
	
	
========================================================
select {o.code} from {Order as o join User as c on {o.user}={c.pk}} where {c.uid} in ('manvendra.raghava@gmail.com') Order by {o.creationtime} DESC 
Query to fetch last order of user .

select {o.code},{c.name} from  {order as o join Customer as c on {c.pk} = {o.user}} where {o.code} in ({{select max({code}) from {order} group by {user}}})
for all customers.

---------------------------------
It doesn't have to do anything with sorting. It's definition is:

If 'true' an additional ordering attribute will be generated for maintaining ordering. Default is 'false'.

To validate this definition, put the following code in the items.xml and execute ant

<items 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			xsi:noNamespaceSchemaLocation="items.xsd">
	<relations>
        <relation code="Item1toItem2" localized="false" generate="true" autocreate="true">
            <sourceElement type="Item1" qualifier="item1" cardinality="one">
                <modifiers read="true" write="true" search="true" optional="true"/>
            </sourceElement>
            <targetElement type="Item2" qualifier="item2s" cardinality="many" ordered="true">
                <modifiers read="true" write="true" search="true" optional="true"/>
            </targetElement>
        </relation>
    </relations>
	
====================================================================

The ConcurrentHashMap class is introduced in JDK 1.5 belongs to java.util.concurrent package, which implements ConcurrentMap as well as to Serializable interface also. ConcurrentHashMap is an enhancement of HashMap as we know that while dealing with Threads in our application HashMap is not a good choice because performance-wise HashMap is not up to the mark.

The default concurrency-level of ConcurrentHashMap is 16.
In ConcurrentHashMap, at a time any number of threads can perform retrieval operation but for updated in the object, the thread must lock the particular segment in which the thread wants to operate. This type of locking mechanism is known as Segment locking or bucket locking. Hence at a time, 16 update operations can be performed by threads.

======================================================================
Hybris come up with concept of Online presence and Actual logistic presence. In hybris Store: refers to actual location. Site : Refers to online presence. Both base store and base site models present in basecommerce extenstion.

Base store : Currency , Language , warehouse

Base Site : Locales

Point of Service: It is a physical branch store with an address
=======================================================================
=======================
query ===>
SELECT {p:code} product, {c:code} Category FROM {Product AS p JOIN CatalogVersion AS cv ON {p:catalogVersion} = {cv:pk} JOIN CategoryProductRelation as cpr ON {cpr:target}={p:pk} JOIN Category as c ON {c:pk}={cpr.source}} 
WHERE {cv:version} = 'Online' AND {p:code}=100029544


=======================================
when there are 3 levels of categories C1 , C1 and C3 where product is associated with category C3 and write a query to get c2 category name from product model?

select {CCR.SOURCE} from {Category as C join CategoryCategoryRelation as CCR on {C.PK}={CCR.SOURCE}} where {CCR.TARGET} IN ({{SELECT {CPR.SOURCE} from {PRODUCT AS P JOIN CategoryProductRelation AS CPR ON  {P.PK}={CPR.TARGET}}  WHERE {P.PK}=8796124086273}})


select {c1.name} from {Category as c1} where {c1.pk} IN ({{select {CCR.SOURCE} from {Category! as C join CategoryCategoryRelation as CCR on {C.PK}={CCR.SOURCE}} where {CCR.TARGET} IN ({{SELECT {CPR.SOURCE} from {PRODUCT AS P JOIN CategoryProductRelation AS CPR ON  {P.PK}={CPR.TARGET}}  WHERE {P.code}='000000000000426811'}})}})

======================================
this method is used in checkout for amway-->
@Override
	public String getCheckoutFlowGroupForCheckout()
	{
		if (getUserService().isAnonymousUser(getUserService().getCurrentUser()) && BooleanUtils.isTrue(sessionService.getCurrentSession().getAttribute(NEW_PARTNER_USER)))
		{
			return "partnerGuestCheckoutGroup"; 
		}
		if (lynxRoleService.isVisitor() || getUserService().isAnonymousUser(getUserService().getCurrentUser()))
		{
			return "guestCheckoutGroup";
		}
		return super.getCheckoutFlowGroupForCheckout();
	}


which is checked on every checkout step getCheckoutGroup() for next step..

================================================
unit testing-->Unit testing is a software development process in which the smallest testable parts of an application, called units, are individually scrutinized for proper operation. Software developers and sometimes QA staff complete unit tests during the development process.

fut-->Functional Unit testing(FUT) , During these phases of testing various test types such as Smoke testing, New Functionality, Regression, Functional end to end, and Risk Based are conducted.

sit ---->System integration testing (SIT) involves the overall testing of a complete system of many subsystem components or elements. The system under test may be composed of hardware, or software, or hardware with embedded software, or hardware/software with human-in-the-loop testing.  end-to-end testing



uat-->User Acceptance Testing (UAT), or application testing, is the final stage of any software development or change request lifecycle before go-live. UAT meaning the final stage of any development process to determine that the software does what it was designed to do in real-world situations.